/**
@page BuildSystemStandard Build System Standard

@section ProjectTemplate Software Project Template

@todo This section has to be written yet.

@section ScriptTargets Build of Script Targets

Unlike source files written in non-scripting languages such as C++ or Java,
source files written in scripting languages such as Python, Perl, or BASH
do not need to be compiled before their execution. They are interpreted
directly and hence do not need to be build (in case of Python, however,
they are as well compiled by the interpreter itself to improve speed).
On the other side, CMake provides a mechanism to replace CMake
variables in a source file by their respective values which are set in the
CMakeLists.txt files (or an included CMake script file). As it is often
useful to introduce build specific information in a script file such as
the relative location of auxiliary executables or data files, the
basis_add_executable() and basis_add_library() commands also provide a
means of building script files, where during the build of the script
the CMake variables as given by <tt>\@VARIABLE_NAME\@</tt> patterns are
replaced by the value of the corresponding CMake variable if defined or
by an empty string otherwise. Similar to the configuration of source files
written in C++ or MATLAB, the names of the script files which shall be
configured by BASIS during the build step have to end with the <tt>.in</tt>
suffix. Otherwise, the script file is not modified by the BASIS build
commands and simply copied to the build tree or installation tree,
respectively. Opposed to configuring the source files already during
the configure step of CMake, as is the case for C++ and MATLAB source files,
script files are configured during the build step to allow for the used
CMake variables to be set differently depending on whether the script is
intended for use inside the build tree or the installation tree.
Moreover, certain properties of the script target can still be modified
after the basis_add_executable() or basis_add_library() command, respectively,
using the basis_set_target_properties() or basis_set_property() command.
Hence, the final values of these variables are not known before the configuration
of the build system has been completed. Therefore, all CMake variables
which are defined when the basis_add_executable() or basis_add_library()
command is called, are dumped to a CMake script file to preserve their value
at this moment and the dump of the variables is written to a file in the
build tree. This file is loaded again during the build step by the custom
build command which eventually configures the script file using CMake's
<a href="http://www.cmake.org/cmake/help/cmake-2-8-docs.html#command:configure_file">
configure_file()</a> command with the <tt>\@ONLY</tt> option.
This build command configures the script file twice. The first "built" script
is intended for use within the build tree while the second "built" script will
be copied upon installation to the installation tree.

Before each configuration of the (template) script file (the <tt>.in</tt>
source file in the source tree), the file with the dumped CMake variable
values and the various script configuration files are included in the
following order:
-# Dump file of CMake variables defined when the script target was added.
-# Default script configuration file of BASIS (BasisScriptConfig.cmake).
-# Default script configuration file of individual project (ScriptConfig.cmake, optional).
-# Script configuration file specified using the @c CONFIG_FILE argument of
   the basis_add_executable() or basis_add_library() command.
-# Script configuration code specified using the @c CONFIG argument of the
   basis_add_executable() or basis_add_library() command.

@subsection ScriptConfig Script Configuration

The so-called script configuration is CMake code which defines CMake variables
for use within script files. This code is either saved in a CMake script file
with the <tt>.cmake</tt> file name extension or specified directly as argument
of the @c CONFIG option of the basis_add_executable() or basis_add_library()
command used to add a script target to the build system. The variables defined
by the script configuration are substituted by their respective values during
the build of the script target. Note that the CMake code of the script
configuration is evaluated during the build of the script target, not during
the configuration of the build system. During the configuration of the build
systems, the script configuration is, however, configured in order to replace
<tt>\@VARIABLE_NAME\@</tt> patterns in the configuration by their respective
values as defined by the build configuration (<tt>CMakeLists.txt</tt> files).
Therefore, the variables defined in the script configuration can be set
differently for each of the two builds of the script files. If the script
configuration is evaluated before the configuration of the script file for use
inside the build tree, the CMake variable @c BUILD_INSTALL_SCRIPT is set to
@c FALSE. Otherwise, if the script configuration is evaluated during the build
of the script for use in the installation tree, this variable is set to
@c TRUE instead. It can therefore be used to set the variables in the script
configuration depending on whether or not the script is build for use in the
build tree or the installation tree.

For example, the project structure differs for the build tree and the
installation tree. Hence, relative file paths to the different directories
of data files, for instance, have to be set differently depending on the value
of @c BUILD_INSTALL_SCRIPT, i.e.,
@code
if (BUILD_INSTALL_SCRIPT)
  set (DATA_DIR "@INSTALL_PREFIX@/@INSTALL_DATA_DIR@")
else ()
  set (DATA_DIR "@PROJECT_DATA_DIR@")
endif ()
@endcode

Avoid the use of absolute paths, however! Instead, use the @c DIR variable
which is set in the build script to the directory of the output script file
to make these paths relative to this directory which contains the configured
script file. These relative paths which are defined by the script configuration
are then used in the script file as follows:
@code
# /usr/bin/env bash
@BASIS_BASH_UTILITIES@
get_executable_directory EXEC_DIR && readonly EXEC_DIR
[ $? -eq 0 ] || { echo 'Failed to determine directory of this executable!'; exit 1; }
readonly DATA_DIR="${EXEC_DIR}/@DATA_DIR@"
@endcode
where @c DATA_DIR is the relative path to the required data files as determined
during the evaluation of the script configuration. See documentation of
the basis_set_script_path() function for a convenience function which can be 
used therefore. Note that this function is defined in the custom build script
generated by BASIS for the build of each script target and hence can only be
used within a script configuration. For example, use this function as follows
in the <tt>PROJECT_CONFIG_DIR/ScriptConfig.cmake.in</tt> script configuration
file of your project:
@code
basis_set_script_path(DATA_DIR "@PROJECT_DATA_DIR@" "@INSTALL_DATA_DIR@")
@endcode

Note that most of the more common variables which are useful for the development
of scripts are already defined by the default script configuration file of
BASIS. Refer to the documentation of the BasisScriptConfig.cmake file for a
list of available variables.

@section CmdLineParsing Command-line Parsing

@subsection CxxCmdLineParsing Parsing the command-line arguments in C++

For the parsing of command-line arguments in C++, BASIS includes a slightly
modified version of the <a href="http://tclap.sourceforge.net/">
Templatized C++ Command Line Parser (TCLAP) Library</a>. For details and
usage of this library, please refer to the TCLAP documentation which is
also included with BASIS and can be found in the <tt>doc/</tt> directory.

The usage of the BASIS TCLAP library shall be demonstrated in the following
on the implementation of an example command-line program. For simplicity,
and to not need to indent the first line, we define the command-line arguments
at the top of our main source file which implements the main() function.
@code
/**
 * @file  smoothimage.cxx
 * @breif Smooth image using Gaussian or anisotropic diffusion filtering.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.<br />
 * See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 */

#include "basis.h" // include BASIS C++ utilities


// acceptable in .cxx file
using namespace std;
using namespace sbia::basis;


// ===========================================================================
// definition of command-line arguments
// ===========================================================================

SwitchArg gaussian(                          // option switch
    "g", "gaussian",                         // short and long option name
    "Smooth image using a Gaussian filter.", // argument help
    false,                                   // required?
    false);                                  // default value

SwitchArg anisotropic(                       // option switch
    "a", "anisotropic",                      // short and long option name
    "Smooth image using anisotropic diffusion filter.", // argument help
    false);                                  // required?

MultiUIntArg gaussian_radius(                // unsigned integer values
    "r", "radius",                           // short and long option name
    "Radius of Gaussian kernel in each dimension.", // argument help
    false,                                   // required?
    "<r_x> <r_y> <r_z>",                     // value type description
    3,                                       // number of values per argument
    true);                                   // accept argument only once

DoubleArg gaussian_std(                      // floating-point argument value
    "s", "std",                              // short and long option name
    "Standard deviation of Gaussian in voxel units.", // argument help
    false,                                   // required?
    2.0,                                     // default value
    "<float>");                              // value type description

// [...]

PositionalArg imagefile(                     // positional, i.e., unlabeled
    "image",                                 // only long option name
    "Image to be smoothed.",                 // argument help
    true,                                    // required?
    "",                                      // default value
    "<image>");                              // value type description

// ===========================================================================
// smoothing filters
// ===========================================================================

// ---------------------------------------------------------------------------
int gaussianfilter(const string&               imagefile,
                   const vector<unsigned int>& r,
                   double                      std)
{
    // [...]
    return 0;
}

// ---------------------------------------------------------------------------
int anisotropicfilter(const string& imagefile)
{
    // [...]
    return 0;
}

// ===========================================================================
// main
// ===========================================================================

// ---------------------------------------------------------------------------
int main(int argc, char* argv[])
{
    try {

    // -----------------------------------------------------------------------
    // construct command-line
    CmdLine cmd(
            // program identification
            "smoothimage", cProjectName,
            // description
            "This program smooths an input image using either a Gaussian "
            "filter or an anisotropic diffusion filter.",
            // example usage
            "EXECNAME --gaussian --std 3.5 --radius 5 5 3 brain.nii"
            "\n"
            "Smooths the image brain.nii using a Gaussian with standard"
            " deviation 3.5 voxel units and 5 voxels in-slice radius and"
            " 3 voxels radius across slices."
            "\n"
            // TODO correct indentation used in sbia::basis::StdOutput
            "EXECNAME  --anisotropic brain.nii"
            "\n"
            "Smooths the image brain.nii using an anisotropic diffusion filter.",
            // version information
            cVersionAndRevision,
            "Copyright (c) 2011 University of Pennsylvania."
            " All rights reserved.");

    cmd.xorAdd(gaussian, anisotropic);
    cmd.add(gaussian_std);
    cmd.add(gaussian_radius);
    cmd.add(imagefile);

    // -----------------------------------------------------------------------
    // parse command-line
    cmd.parse(argc, argv);

    // -----------------------------------------------------------------------
    // catch specification exceptions - parse errors are already taken care of
    } catch (CmdLineException& e) {
        // invalid command-line specification
        cerr << e.error() << endl;
        exit(1);
    }

    // -----------------------------------------------------------------------
    // smooth image - access parsed argument value using Arg::getValue()
    unsigned int r[3];

    if (gaussian.getValue()) {
        return gaussianfilter(imagefile.getValue(),
                              gaussian_radius.getValue(),
                              gaussian_std.getValue());
    } else {
        return anisotropicfilter(imagefile.getValue());
    }
}

@endcode

The constructor of sbia::basis::CmdLine will further add the standard arguments
--verbose, --help, --helpshort, --helpxml, --helpman, and --version.

Running the above program with the --help option will give the following
output:
@verbatim

SYNOPSIS
    smoothimage [--std <float>] [--radius <r_x> <r_y> <r_z>] [--verbose
                |-v] {--gaussian|--anisotropic} <image>
    smoothimage [--help|-h|--helpshort|--helpxml|--helpman|--version]

DESCRIPTION
    This program smooths an input image using either a Gaussian filter or
    an anisotropic diffusion filter.

OPTIONS
    Required arguments:
       -g or --gaussian
            Smooth image using a Gaussian filter.
       or -a or --anisotropic
            Smooth image using anisotropic diffusion filter.

       <image>
            Image to be smoothed.

    Optional arguments:
       -s or --std <float>
            Standard deviation of Gaussian in voxel units.

       -r or --radius <r_x> <r_y> <r_z>
            Radius of Gaussian kernel in each dimension.

    Standard arguments:
       -- or --ignore_rest
            Ignores the rest of the labeled arguments following this flag.

       -v or --verbose
            Increase verbosity of output messages.

       -h or --help
            Display help and exit.

       --helpshort
            Display short help and exit.

       --helpxml
            Display help in XML format and exit.

       --helpman
            Display help as man page and exit.

       --version
            Display version information and exit.

EXAMPLE
    smoothimage --gaussian --std 3.5 --radius 5 5 3 brain.nii

        Smooths the image brain.nii using a Gaussian with standard
        deviation 3.5 voxel units and 5 voxels in-slice radius and 3 voxels
        radius across slices.

    smoothimage  --anisotropic brain.nii

        Smooths the image brain.nii using an anisotropic diffusion filter.

CONTACT
    SBIA Group <sbia-software at uphs.upenn.edu>

@endverbatim

The short help output contains of only the synopsis of the full help, i.e.,
@verbatim

    smoothimage [--std <float>] [--radius <r_x> <r_y> <r_z>] [--verbose
                |-v] {--gaussian|--anisotropic} <image>
    smoothimage [--help|-h|--helpshort|--helpxml|--helpman|--version]

@endverbatim

Copyright (c) 2011 University of Pennsylvania. All rights reserved.
See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.

Contact: SBIA Group <sbia-software at uphs.upenn.edu>
*/
