/*!
 * \file  execname.cpp.in
 * \brief Maps CMake target name to executable name.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See LICENSE or Copyright file in project root directory for details.
 *
 * Contact: SBIA Group <sbia-software -at- uphs.upenn.edu>
 */


#include <string>
#include <iostream>

#include <boost/program_options.hpp>


using namespace std;

namespace po = boost::program_options;
 

// ===========================================================================
// target name => executable name
// ===========================================================================

#if @NUMBER_OF_TARGETS@ > 0 // numberOfTargets > 0


//! Number of targets.
const int numberOfTargets = @NUMBER_OF_TARGETS@;

//! Maps target names to executable names.
const char * const targetNameToExecNameMap [numberOfTargets][2] =
{
@TARGET_NAME_TO_EXECUTABLE_NAME_MAP@
};


#else // numberOfTargets > 0


//! Number of targets.
const int numberOfTargets = 0;

//! Maps target names to executable names.
const char *** const targetNameToExecNameMap = NULL;


#endif // numberOfTargets > 0

// ===========================================================================
// version / usage / help
// ===========================================================================

/*!
 * \brief Extract program name from first command line argument.
 *
 * \param argv Command line arguments.
 *
 * \return Program name without relative or absolute path to directory where
 *         the executable is located. Do not try to free the memory of the
 *         returned pointer! It just points to the first character of the
 *         program name within argv [0].        
 */
inline
const char *getProgName (char *argv[])
{
	const char *progName = argv [0];

	if (progName && *progName)
	{
		// go to last character of string
		while (*progName) ++progName;
		--progName;
		// rewind until beginning of string or
		// '/' (UNIX) or '\\' (WIN) is encountered
		while (progName != argv [0])
		{
			--progName;
			if (*progName == '/' || *progName == '\\')
			{
				++progName;
				break;
			}
		}
	}

	return progName;
}

/*!
 * \brief Prints version information.
 *
 * \param [in] progName Name of program.
 */
void version (const char *progName)
{
	cout << progName << " @PROJECT_VERSION@";
#if @PROJECT_REVISION@ > 0 // PROJECT_REVISION > 0
	cout << " (Rev. " <<  @PROJECT_REVISION@ << ')';
#endif
	cout << endl;
}

/*!
 * \brief Prints usage information.
 *
 * \param [in] progName Name of program.
 * \param [in] desc     Program options description.
 */

void usage (const char *progName, const po::options_description &desc)
{
    version (progName);
    cout << endl;
    cout << "Usage:" << endl;
    cout << "  " << progName << " [options]" << endl;
    cout << endl;
    cout << desc;
    cout << endl;
    cout << "Example:" << endl;
    cout << "  " << progName << " TargetName" << endl;
    cout << "  " << progName << " ProjectName@TargetName" << endl;
    cout << endl;
    cout << "Contact:" << endl;
    cout << "  SBIA Group <sbia-software -at- uphs.upenn.edu>" << endl;
}

// ===========================================================================
// main
// ===========================================================================

int main (int argc, char *argv [])
{
    const char * const progName = getProgName (argv);

    // -----------------------------------------------------------------------
    // options
    // -----------------------------------------------------------------------

    string tgt; // name of CMake target
    string ns;  // default namespace

    po::options_description vo ("Options"); // visible options
    po::variables_map       vm;             // stores parsed values

    try
    {
        // allowed options
        po::options_description allowed ("Allowed options");
        allowed.add_options ()
            ("namespace,ns", po::value <string> (&ns)->default_value (""),
             "Default namespace of non-fully qualified target names.")
        ;

        // generic options
        po::options_description generic ("Generic options");
        generic.add_options ()
            ("help,h",    "Print help and exit.")
            ("version,V", "Print version and exit.")
            ("verbose,v", "Increase verbosity of output messages.")
        ;

        // hidden options
        po::options_description hidden ("Hidden options");
        hidden.add_options ()
            ("target-name", po::value <string> (&tgt), "Name of CMake target.")
        ;

        // visible options
        vo.add (allowed).add (generic);

        // positional options
        po::positional_options_description p;
        p.add ("target-name", -1);

        // non-positional options
        po::options_description o;
        o.add (allowed).add (generic).add (hidden);

        // parse options
        po::store (po::command_line_parser (argc, argv).options (o).positional (p).run (), vm);
        po::notify (vm);
    }
    catch (const exception &e)
    {
        usage (progName, vo);
        cerr << e.what () << endl;
        exit (EXIT_FAILURE);
    }

    // handle generic options
    if (vm.count ("help") || vm.count ("usage"))
    {
        usage (progName, vo);
        exit (EXIT_SUCCESS);
    }

    if (vm.count ("version"))
    {
        version (progName);
        exit (EXIT_SUCCESS);
    }

    // required options given ?
    if (tgt.empty ())
    {
        usage (progName, vo);
        exit (EXIT_FAILURE);
    }

    // append default namespace to non-fully qualified target name
    if (tgt.find ('@') == string::npos && !ns.empty ())
    {
        tgt += '@';
        tgt += ns;
    }

    // -----------------------------------------------------------------------
    // map target name to executable name
    // -----------------------------------------------------------------------

    const char * const targetName = tgt.c_str ();
    const char *       execName   = targetName;

    for (unsigned int i = 0; i < numberOfTargets; ++ i)
    {
        if (strcmp (targetName, targetNameToExecNameMap [i][0]) == 0)
        {
            execName = targetNameToExecNameMap [i][1];
            break;
        }
    }

    // -----------------------------------------------------------------------
    // print executable name
    // -----------------------------------------------------------------------

    cout << execName;

    exit (EXIT_SUCCESS);
}
