#! /usr/bin/env bash

##############################################################################
# \file  basistest-master.sh
# \brief Test master which can be run as a cron job.
#
# This shell script is supposed to be scheduled as cron job, where possibly
# the basistest-cron.sh script is in fact used as cron job command without
# arguments where all the settings for the cron job are fixed within this
# latter script. On execution, this master script parses the configuration
# file and executes the configured tests using by default the
# basistest-slave.sh script.
#
# Copyright (c) 2011 University of Pennsylvania. All rights reserved.
# See COPYING file or https://www.rad.upenn.edu/sbia/software/license.html.
#
# Contact: SBIA Group <sbia-software at uphs.upenn.edu>
##############################################################################

# ============================================================================
# BASIS functions (automatically generated by BASIS)
# ============================================================================

@BASH_FUNCTION_getProgDir@
@BASH_FUNCTION_getProgName@

# ============================================================================
# settings
# ============================================================================

# executable information
progName=$(getProgName)
progDir=$(getProgDir)
version='@VERSION@'
revision='@REVISION@'

# absolute path of tests configuration file
confFile='/etc/basistest.conf'

# absolute path of file with timestamps for next test execution
scheduleFile='/var/run/basistest.schedule'

# ============================================================================
# help/version
# ============================================================================

# ****************************************************************************
# \brief Print version information.
printVersion ()
{
    if [ ! -z $revision -o $revision -gt 0 ]; then
        echo "basistest-master (BASIS) $version (Rev. $revision)"
    else
        echo "basistest-master (BASIS) $version"
    fi
    cat - << EOF-COPYRIGHT
Copyright (c) 2011 University of Pennsylvania. All rights reserved.
See COPYING file or https://www.rad.upenn.edu/sbia/software/license.html.
EOF-COPYRIGHT
}

# ****************************************************************************
# \brief Print usage section of help/usage.
printUsageSection ()
{
    echo "Usage:"
    echo "  $progName [options]"
}

# ****************************************************************************
# \brief Print documentation of options.
printOptionsSection ()
{
    cat - << EOF-OPTIONS
Options:
  -c [ --conf ]       The test configuration file. Defaults to "$confFile".
  -t [ --testcmd ]    The test execution command. Defaults to the basistest
                      command in the same directory as this executable.
  -s [ --schedule ]   The test schedule file which is created and updated by
                      this program. Defaults to "$scheduleFile".
  --dry               Dry run, i.e., do not actually invoke the test execution command.
  -V [ --verbose ]    Increases verbosity of output messages. Can be given multiple times.
  -h [ --help ]       Print help and exit.
  -u [ --usage ]      Print usage information and exit.
  -v [ --version ]    Print version information and exit.
EOF-OPTIONS
}

# ****************************************************************************
# \brief Print contact information.
printContactSection ()
{
    echo "Contact:"
    echo "  SBIA Group <sbia-software at uphs.upenn.edu>"
}

# ****************************************************************************
# \brief Print help.
printHelp ()
{
    echo "$progName (BASIS)"
    echo
    printUsageSection
    echo
    cat - << EOF-DESCRIPTION
Description:
  This so-called testing master script is executed by the basistest-cron command.
  On each run, it reads in the configuration file given by the -c (--config) option
  line-by-line. Each line in the configuration file specifies one test job to be
  executed. See the next section for details on the format and content of such
  configuration file.

Configuration:
  The format of the configuration file is detailed here. Comments within the
  configuration file start with a '#' character at the beginning of each line.

  For each test of a specific branch of a project, the configuration file
  contains a line following the format:

    <m>:<h>:<d>:<project>:<branch>:<model>:<options>

  where

    <m>         Interval in minutes between consecutive test runs.
                Defaults to "0" if "*" is given.
    <h>         Interval in hours between consecutive test runs.
                Defaults to "0" if "*" is given.
    <d>         Interval in days (i.e., multiples of 24 hours) between consecutive
                test runs. Defaults to "0" if "*" is given.
    <project>   Name of the BASIS project.
    <branch>    Branch within the project's SVN repository, e.g., "tags/1.0.0".
                Defaults to "trunk" if a "*" is given.
    <model>     Dashboard model, i.e., either one of "Nightly", "Continuous",
                and "Experimental". Defaults to "Nightly".
    <options>   Additional options to the CTest script.
                The "basisctest" script of BASIS is used by default.
                Run "ctest -S <path>/basisctest,usage" to get a list of
                available options. By default, the default options of the
                CTest script are used.

  For example, nightly tests of the main development branch (trunk) of the
  project BASIS itself which are run once every day including coverage
  analysis and memory checks are scheduled by

    *:*:1:BASIS:trunk:Nightly:coverage,memcheck

  Attention: The entire line may not contain any whitespace character!

Test execution:
  By default, the "basistest-slave" command is invoked for each entry in
  the configuration file. A custom test command can be set using the option
  -t [ --testcmd ]. The provided command has to support the following
  command line arguments.

    --project <arg>   The name of the project as given in the configuration.
    --branch <arg>    The branch as given in the configuration.
    --model <arg>     The name of the model as given in the configuration.
    --args <arg>      The additional options given in the configuration.
    --verbose         Enable verbose output messages. May be given multiple times.

  The --args and --verbose options have to be optional.
EOF-DESCRIPTION
    echo
    printOptionsSection
    echo
    cat - << EOF-EXAMPLES
Examples:
  $progName --conf /etc/basis/testd.conf --schedule /var/run/basis/testd

    Runs this daemon with the configuration file "/etc/basis/testd.conf",
    where the test schedule "/var/run/basis/testd" is created (or updated).
    Note that this command should be setup as cron job instead of executing
    it manually.
EOF-EXAMPLES
    echo
    printContactSection
}

# ****************************************************************************
# \brief Print usage (i.e., only usage and options).
printUsage ()
{
    echo "$progName (BASIS)"
    echo
    printUsageSection
    echo
    printOptionsSection
    echo
    printContactSection
}

# ============================================================================
# helpers
# ============================================================================

# ****************************************************************************
# \brief Runs a test given the arguments in the configuration file.
runTest ()
{
    cmd="$testCmd"
    if [ $verbosity -gt 1 ]; then cmd="$cmd --verbose"; fi
    if [ $verbosity -gt 2 ]; then cmd="$cmd --verbose"; fi
    cmd="$cmd --project $1 --branch $2 --model $3"
    if [ ! -z "$options" ]; then cmd="$cmd --args $options"; fi
    if [ $verbosity -gt 0 ]; then
        echo "Run $cmd"
    fi
    if [ $dry -eq 0 ]; then
        if [ $verbosity -gt 0 ]; then
            $cmd
        else
            $cmd > /dev/null # avoid messages such as "Your job has been submitted"
        fi
        return $?
    fi
    return 0
}

# ****************************************************************************
# \brief Convert date to timestamp.
#
# \param [in] $1 Date.
#
# \return Timestamp corresponding to given date.
date2stamp ()
{
    if [ $(uname) == 'Darwin' ]; then
        date -j -f '%Y-%m-%d %T' "$1" +%s
    else
        date -d "$1" +%s
    fi
}

# ****************************************************************************
# \brief Convert timestamp to date.
#
# \param [in] $1 Timestamp.
#
# \return Date corresponding to given timestamp.
stamp2date ()
{
    if [ $(uname) == 'Darwin' ]; then
      date -j -r $1 '+%Y-%m-%d %T'
    else
      date -d "1970-01-01 $1 sec UTC" '+%Y-%m-%d %T'
    fi
}

# ****************************************************************************
# \brief Adds a certain time interval to a given date.
#
# \param [in] $1 Unit of the time interval. Either one of -s, -m, -h, or -d.
#                Defaults to number of days.
# \param [in] $2 The date to which the time interval is added.
# \param [in] $3 The time interval given in the specified units.
#
# \return The date which is $3 time units after the given date.
dateAdd ()
{
    case $1 in
        -s) sec=1;      shift;;
        -m) sec=60;     shift;;
        -h) sec=3600;   shift;;
        -d) sec=86400;  shift;;
         *) sec=86400;;
    esac
    local dte1=$(date2stamp "$1")
    local interval=$2
    local addSec=$((dte1 + interval * sec))
    echo $(stamp2date "$addSec")
}

# ****************************************************************************
# \brief Computes the time interval between two given dates.
#
# \param [in] $1 Unit of the time interval. Either one of -s, -m, -h, or -d.
#                Defaults to number of days.
# \param [in] $2 The first date.
# \param [in] $3 The second date.
#
# \return Time interval, i.e., an absolute value, in the given units.
dateDiff ()
{
    case $1 in
        -s) sec=1;      shift;;
        -m) sec=60;     shift;;
        -h) sec=3600;   shift;;
        -d) sec=86400;  shift;;
         *) sec=86400;;
    esac
    local dte1=$(date2stamp "$1")
    local dte2=$(date2stamp "$2")
    local interval=$((dte2 - dte1))
    echo $((interval / sec))
}

# ****************************************************************************
# \brief Get next scheduled date of a given test.
scheduleDate ()
{
    local retval=$(date '+%Y-%m-%d %T')
    idx=0
    num=${#schedule[@]}
    while [ $idx -lt $num ]; do
        parts=(${schedule[$idx]})
        num=${#parts[@]}
        if [ $num -lt 5 -o $num -gt 6 ]; then continue; fi
        if [    "${parts[2]}" == "$1" \
             -a "${parts[3]}" == "$2" \
             -a "${parts[4]}" == "$3" \
             -a "${parts[5]}" == "$4" ]
        then
            retval="${parts[0]} ${parts[1]}"
        fi
        ((idx++))
    done
    echo "$retval"
}

# ***************************************************************************
# \brief Add entry to test schedule.
scheduleTest ()
{
    idx=${#newSchedule[@]}
    newSchedule[$idx]="$1 $2 $3 $4 $5"
}

# ============================================================================
# options
# ============================================================================

testCmd="$progDir/basistest" # command used to run tests
verbosity=0                  # verbosity of output messages
dry=0                        # whether this is a dry testing run

while [ $# -gt 0 ]; do
	case "$1" in
        -c|--conf)
            shift
            if [ $# -gt 0 ]; then
                confFile=$1
            else
                echo "Option -c [ --conf ] requires an argument!" 1>&2
                exit 1
            fi
            ;;
        -t|--testcmd)
            shift
            if [ $# -gt 0 ]; then
                testCmd=$1
            else
                echo "Option -t [ --testCmd ] requires an argument!" 1>&2
                exit 1
            fi
            ;;
        -s|--schedule)
            shift
            if [ $# -gt 0 ]; then
                scheduleFile=$1
            else
                echo "Option -s [ --schedule ] requires an argument!" 1>&2
                exit 1
            fi
            ;;
        --dry) dry=1; ;;

        # standard options
		-h|--help)    printHelp;    exit 0; ;;
		-u|--usage)   printUsage;   exit 0; ;;
        -v|--version) printVersion; exit 0; ;;
        -V|--verbose) ((verbosity++)); ;;

        # invalid option
        *)
            printUsage
            echo
            echo "Invalid option $1!" 1>&2
            ;;
    esac
    shift
done

# ============================================================================
# main
# ============================================================================

# check existence of configuration file
if [ ! -f "$confFile" ]; then
    echo "Missing configuration file $confFile" 1>&2
    exit 1
fi

# check existence of test command
which $testCmd &> /dev/null
if [ $? -ne 0 ]; then
    echo "Could not find test command $testCmd" 1>&2
    exit 1
fi



# parse existing test schedule
schedule=()
newSchedule=()
if [ -f "$scheduleFile" ]; then
    idx=0
    while read line; do
        schedule[$idx]=$line
        ((idx++))
    done < $scheduleFile
fi

# variables set by readConfLine () which store the configuration for a
# particular test run
minutes=0
hours=0
days=0
project=''
branch=''
model=''
options=''

# read configuration file line by line
linenumber=0
errors=0
while read line; do
    ((linenumber++))
    # skip empty lines
    if [ -z "$line" ]; then continue; fi
    # skip comments
    if [[ "$line" =~ "^#" ]]; then continue; fi
    # sanitize line
    line=${line//\*/x}
    # "parse" line
    parts=($line)
    num=${#parts[@]}
    if [ $num -lt 4 ]; then
        echo "$confFile:$linenumber: Invalid configuration, skipping test" 1>&2
        ((errors++))
        continue
    fi
    minutes=${parts[0]}
    hours=${parts[1]}
    days=${parts[2]}
    project=${parts[3]}
    branch=${parts[4]}
    model=${parts[5]}
    options=${parts[6]}
    # check arguments
    if [ -z "$minutes" -o -z "$hours" -o -z "$days" ]; then
        echo "$confFile:$linenumber: Invalid configuration, skipping test" 1>&2
        ((errors++))
        continue
    fi
    if [ "$minutes" == "x" ]; then minutes=0; fi
    if [ "$hours"   == "x" ]; then hours=0;   fi
    if [ "$days"    == "x" ]; then days=0;   fi
    if [ $minutes -eq 0 -a $hours -eq 0 -a $days -eq 0 ]; then
        echo "$confFile:$linenumber: Invalid test interval, skipping test" 1>&2
        ((errors++))
        continue
    fi
    if [ -z "$project" ]; then
        echo "$confFile:$linenumber: No project name given, skipping test" 1>&2
        ((errors++))
        continue
    fi
    if [ -z "$branch" ]; then
        branch='trunk'
    fi
    if [ -z "$model" ]; then
        model='Nightly'
    fi
    # determine whether test is already due for execution
    nextDate=$(scheduleDate $project $branch $model $options)
    if [ $(dateDiff -m "$(date '+%Y-%m-%d %T')" "$nextDate") -gt 0 ]; then
        if [ $verbosity -gt 0 ]; then
            echo "Next $model test of $project ($branch) with options \"$options\" is scheduled for $nextDate"
        fi
        # skip test as it is not yet scheduled for execution
        scheduleTest "$nextDate" "$project" "$branch" "$model" "$options"
        continue
    fi
    # run test
    runTest $project $branch $model $options
    if [ $? -ne 0 ]; then
        echo "$confFile:$linenumber: Failed to run test" 1>&2
        ((errors++))
        # do not retry failing test too often
        minutes=0
        hours=1
        days=0
    fi
    # update time of next execution
    minutes=$((minutes + hours * 60 + days * 1440))
    nextDate=$(dateAdd -m "$(date '+%Y-%m-%d %T')" "$minutes")
    scheduleTest "$nextDate" "$project" "$branch" "$model" "$options"
    if [ $? -ne 0 ]; then
        echo "$confFile:$linenumber: Failed to reschedule test" 1>&2
        ((errors++))
    fi
    if [ $verbosity -gt 0 ]; then
        echo "Test will re-execute in $minutes minutes from now ($(date '+%Y-%m-%d %T')), i.e., not before $nextDate"
    fi
done < "$confFile"

# write new schedule
rm -f $scheduleFile
idx=0
num=${#newSchedule[@]}
while [ $idx -lt $num ]; do
    echo ${newSchedule[$idx]} >> $scheduleFile
    if [ $? -ne 0 ]; then
        echo "Failed to write schedule to file $scheduleFile!" 1&>2
        break
    fi
    ((idx++))
done
if [ -f $scheduleFile ]; then
    sort "$scheduleFile" -o "$scheduleFile"
fi

# done
if [ $errors -ne 0 ]; then
    exit 1
fi
exit 0
