##############################################################################
# @file  stdaux.py
# @brief Standard auxiliary functions for @PROJECT_NAME@.
#
# @note The stdaux.py module is automatically created by BASIS from the
#       template file stdaux.py.in which is part of the BASIS installation.
#
# Copyright (c) 2011, 2012 University of Pennsylvania. All rights reserved.<br />
# See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
#
# Contact: SBIA Group <sbia-software at uphs.upenn.edu>
#
# @ingroup BasisPythonUtilities
##############################################################################

"""
Standard auxiliary functions for @PROJECT_NAME@.

Copyright (c) 2011, 2012 University of Pennsylvania. All rights reserved.
See COPYING file or https://www.rad.upenn.edu/sbia/software/license.html.

Contact: SBIA Group <sbia-software at uphs.upenn.edu>

"""


## @addtogroup BasisPythonUtilities
# @{


# ============================================================================
# imports
# ============================================================================

from os         import path                 as _path
from sbia.basis import utilities            as _utilities
from .          import executabletargetinfo as _executabletargetinfo

# ============================================================================
# executable information
# ============================================================================

# ----------------------------------------------------------------------------
from sbia.basis.utilities import print_contact

# ----------------------------------------------------------------------------
def print_version(name, copyright=None, license=None):
    """Print version information including copyright and license notices.

    @param [in] name      Name of executable. Should not be set programmatically
                          to the first argument to the __main__ module.
    @param [in] copyright The copyright notice. If None, the default copyright
                          without year is used, which is not recommended as the
                          copyright years should always be included. If an
                          empty string is given, no copyright notice is printed.
    @param [in] license   Information regarding licensing. If None, the default
                          software license is used. If an empty string is given,
                          no license information is printed.

    """
    _utilities.print_version(name, '@PROJECT_RELEASE@', project='@PROJECT_NAME@', copyright=copyright, license=license)

# ----------------------------------------------------------------------------
def get_executable_path(name=None):
    """Get absolute path of executable file."""
    path = _executabletargetinfo.get_executable_path(name)
    if not path: path = _utilities.get_executable_path(name)
    return path

# ----------------------------------------------------------------------------
def get_executable_name(name=None):
    """Get name of executable file.

    If no name is specified, the name of this executable is returned.

    """
    path = get_executable_path(name)
    if path is None: return None
    return _path.basename(path)

# ----------------------------------------------------------------------------
def get_executable_directory(name=None):
    """Get directory of executable file.

    If no executable is specified, the directory of this executable is returned.

    """
    path = get_executable_path(name)
    if path is None: return None
    return _path.dirname(path)

# ============================================================================
# command execution
# ============================================================================

# ----------------------------------------------------------------------------
from sbia.basis.utilities import SubprocessError

# ----------------------------------------------------------------------------
def execute_process(args, quiet=False, stdout=False, allow_fail=False, verbose=0, simulate=False):
    """Execute command as subprocess.
    
    @param [in] args       Command with arguments given either as single quoted
                           string or array of command name and arguments.
                           In the latter case, the array elements are converted
                           to strings using the built-in str() function.
                           Hence, any type which can be converted to a string
                           can be used. The first argument must be the name
                           or path of the executable of the command or the
                           name of the corresponding build target.
    @param [in] quiet      Turns off output of stdout of child process to
                           stdout of parent process.
    @param [in] stdout     Whether to return the command output.
    @param [in] allow_fail If true, does not raise an exception if return
                           value is non-zero. Otherwise, a SubprocessError is
                           raised by this function.
    @param [in] verbose    Verbosity of output messages.
                           Does not affect verbosity of executed command.
    @param [in] simulate   Whether to simulate command execution only.
    
    @return A tuple consisting of exit code of executed command and command
            output if both @p stdout and @p allow_fail are True.
            If only @p stdout is True, only the command output is returned.
            If only @p allow_fail is True, only the exit code is returned.
            Otherwise, this function always returns 0.
    
    @throws SubprocessError If command execution failed. This exception is not
                            raised if the command executed with non-zero exit
                            code but @p allow_fail set to True.
    
    """
    # convert args to list of strings
    args = _utilities.to_array_of_strings(args)
    # get absolute path of executable
    path = get_executable_path(args[0])
    if not path: raise SubprocessError(args[0] + ": Command not found")
    args[0] = path
    # execute subprocess
    _utilities.execute_process(args, quiet=quiet,
                                     stdout=stdout,
                                     allow_fail=allow_fail,
                                     verbose=verbose,
                                     simulate=simulate)


## @}
# end of Doxygen group
