/**
 * @file  config.h
 * @brief Default include file with project configuration.
 *
 * @note The config.h file is automatically generated by BASIS from the
 *       file config.h.in which is part of BASIS.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 *
 * @ingroup CMakeTemplates CppUtilities
 */

#pragma once
#ifndef SBIA_@PROJECT_NAME_UPPER@_CONFIG_H_
#define SBIA_@PROJECT_NAME_UPPER@_CONFIG_H_


#include <string>


/// @addtogroup CppUtilities
/// @{

// ===========================================================================
// system
// ===========================================================================

/// @def   LINUX
/// @brief Whether the sources are compiled on a Linux system.
#ifndef LINUX
#  define LINUX (defined (linux) || defined (__linux))
#endif

/// @def   WINDOWS
/// @brief Whether the sources are compiled on a Windows system.
#ifndef WINDOWS
#  define WINDOWS (defined (_WIN32) || defined (WIN32) || defined (_WINDOWS))
#endif

/// @def   MACOS
/// @brief Whether the sources are compiled on a Mac OS system.
#ifndef MACOS
#  define MACOS (defined (__APPLE__) || defined (__OSX__))
#endif

/// @def   UNIX
/// @brief Whether the sources are compiled on a Unix-based system.
#ifndef UNIX
#  define UNIX (!WINDOWS)
#endif

/// @def   HAVE_LONG_LONG
/// @brief Whether the long long type is supported by the compiler.
#ifdef HAVE_LONG_LONG
#  if HAVE_LONG_LONG != @HAVE_LONG_LONG@
#    error "Macro HAVE_LONG_LONG was previously defined with different value!"
#  endif
#else
#  define HAVE_LONG_LONG @HAVE_LONG_LONG@
#endif

/// @def HAVE_SSTREAM
/// @brief Whether the ANSI string stream classes are available.
#ifdef HAVE_SSTREAM
#  if HAVE_SSTREAM != @HAVE_SSTREAM@
#    error "Macro HAVE_SSTREAM was previously defined with different value!"
#  endif
#else
#  define HAVE_SSTREAM @HAVE_SSTREAM@
#endif

/**
 * @def   HAVE_STRSTREAM
 * @brief Whether the obsolete string stream classes are available.
 *
 * @note As the strstream implementations are obsolete already for a long
 *       time, this macro always evaluates to 0.
 */
#ifdef HAVE_STRSTREAM
#  undef HAVE_STRSTREAM
#endif
#define HAVE_STRSTREAM 0

/// @def HAVE_PTHREAD
/// @brief Whether the pthread library is available.
#ifdef HAVE_PTHREAD
#  if HAVE_PTHREAD != @HAVE_PTHREAD@
#    error "Macro HAVE_PTHREAD was previously defined with different value!"
#  endif
#else
#  define HAVE_PTHREAD @HAVE_PTHREAD@
#endif

/**
 * @def HAVE_TR1_TUPLE
 * @brief Whether the tr1/tuple header file is available.
 *
 * @note This header file is only more recently supported by compilers
 *       and be used by Google Test, for example. If not supported by
 *       the compiler, Google Test can use it's own implementation.
 */
#ifdef HAVE_TR1_TUPLE
#  if HAVE_TR1_TUPLE != @HAVE_TR1_TUPLE@
#    error "Macro HAVE_TR1_TUPLE was previously defined with different value!"
#  endif
#else
#  define HAVE_TR1_TUPLE @HAVE_TR1_TUPLE@
#endif

// ===========================================================================
// namespace
// ===========================================================================

/**
 * @brief Full project own namespace identifier.
 *
 * This macro should preferably be used when referring to the project own
 * namespace. The namespace can then be renamed later on without affecting
 * written source code.
 *
 * @note Namespace identifier may reflect a nested namespace.
 */
#define SBIA_@PROJECT_NAME_UPPER@_NAMESPACE \
    ::sbia::@PROJECT_NAME_LOWER@

/**
 * @brief Macro used to enter project own namespace.
 *
 * Example: 
 * @code
 * SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN
 *
 * // project source code within project own namespace
 *
 * SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
 * @endcode 
 */ 
#define SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN \
    namespace sbia { namespace @PROJECT_NAME_LOWER@ {

/**
 * @brief Macro used to exit project own namespace.
 *
 * Example: 
 * @code
 * SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN
 *
 * // project source code within project own namespace
 *
 * SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
 * @endcode 
 */
#define SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END } }

// ===========================================================================
// constants
// ===========================================================================

SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN


// ---------------------------------------------------------------------------
// project attributes
// ---------------------------------------------------------------------------

/// @brief The project name.
extern const std::string cProjectName;

/// @brief The project name in lowercase only.
extern const std::string cProjectNameLower;

/// @brief The project name in uppercase only.
extern const std::string cProjectNameUpper;

/// @brief The major version number.
extern const unsigned int cVersionMajor;

/// @brief The minor version number.
extern const unsigned int cVersionMinor;

/// @brief The patch number.
extern const unsigned int cVersionPatch;

/// @brief The version string given as "<major>.<minor>.<patch>".
extern const std::string cVersion;

/**
 * @brief The Subversion revision number of the project.
 *
 * Note that the revision number is not known when the software is built
 * from a source distribution package instead of a Subversion working copy.
 * In this case, the revision number is set to 0, an invalid revision number.
 * Therefore, the revision number should only be used within the version
 * information of executables, but not for conditional execution.
 */
extern const unsigned int cRevision;

// ---------------------------------------------------------------------------
// paths
// ---------------------------------------------------------------------------

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// build tree
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/**
 * @brief Absolute path of top directory of build tree.
 *
 * This constant is set to the absolute path of the top directory of the build
 * tree in which the software is built. It can be used to determine whether
 * an executable was executed from within the build tree rather than an
 * installation.
 *
 * @sa GetInstallationDirectory()
 */
extern const std::string cBuildRoot;

/**
 * @brief Absolute path to runtime executables in build tree.
 *
 * @sa GetRuntimeDirectory()
 */
extern const std::string cRuntimeBuildPath;

/**
 * @brief Absolute path to auxiliary executables in build tree.
 *
 * @sa GetLibexecDirectory()
 */
extern const std::string cLibexecBuildPath;

/**
 * @brief Absolute path to modules and shared libraries in build tree.
 *
 * @sa GetLibraryDirectory()
 */
extern const std::string cLibraryBuildPath;

/**
 * @brief Absolute path to auxiliary data files in build tree.
 *
 * @sa GetDataDirectory()
 */
extern const std::string cDataBuildPath;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// installation
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/**
 * @brief Path prefix used by runtime executables.
 *
 * This path prefix is used by runtime executables as prefix for any of the
 * relative path constants defined globally.
 *
 * Example:
 * @code
 * std::string path = GetExecutableDirectory () + cRuntimePathPrefix + cDataPath;
 * @endcode
 *
 * The resulting path is the absolute path to the shared data directory if
 * executed by a main executable which is located in the runtime directory.
 *
 * @sa GetInstallationDirectory()
 */
extern const std::string cRuntimePathPrefix;

/**
 * @brief Path prefix used by auxiliary executables.
 *
 * This path prefix is used by auxiliary executables as prefix for any of the
 * relative path constants defined globally.
 *
 * Example:
 * @code
 * std::string path = GetExecutableDirectory () + cLibexecPathPrefix + cDataPath;
 * @endcode
 *
 * The resulting path is the absolute path to the shared data directory if
 * executed by an auxiliary executable which is located in the libexec directory.
 *
 * @sa GetInstallationDirectory()
 */
extern const std::string cLibexecPathPrefix;

/**
 * @brief Path to runtime executables relative to executable directory.
 *
 * @sa cRuntimePathPrefix
 * @sa cLibexecPathPrefix
 *
 * @sa GetRuntimeDirectory()
 */
extern const std::string cRuntimePath;

/**
 * @brief Path to auxiliary executables relative to executable directory.
 *
 * @sa cRuntimePathPrefix
 * @sa cLibexecPathPrefix
 *
 * @sa GetLibexecDirectory()
 */
extern const std::string cLibexecPath;

/**
 * @brief Path to modules and shared libraries relative to executable directory.
 *
 * @sa cRuntimePathPrefix
 * @sa cLibexecPathPrefix
 *
 * @sa GetLibraryDirectory()
 */
extern const std::string cLibraryPath;

/**
 * @brief Path to shared data relative to executable path prefix.
 *
 * @sa cRuntimePathPrefix
 * @sa cLibexecPathPrefix
 *
 * @sa GetDataDirectory()
 */
extern const std::string cDataPath;


/// @}


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END


#endif // SBIA_@PROJECT_NAME_UPPER@_CONFIG_H_

