/**
 * @file  basis.h
 * @brief BASIS Utilities of @PROJECT_NAME@ package.
 *
 * @note The basis.h module was automatically generated by BASIS from the
 *       template file basis.h.in which is part of the BASIS installation.
 *
 * This header file includes the header files of the remaining BASIS Utilities.
 * Hence, it is sufficient to only include this header file.
 *
 * Copyright (c) 2011, 2012 University of Pennsylvania. All rights reserved.<br />
 * See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 *
 * @ingroup BasisCxxUtilities
 */

// do not use pragma once here as this file may be part of a custom template
// basis.h.in file provided by the project developer
#ifndef _@BASIS_NAMESPACE_UPPER@_@PROJECT_NAME_UPPER@_BASIS_H
#define _@BASIS_NAMESPACE_UPPER@_@PROJECT_NAME_UPPER@_BASIS_H

#include <string>
#include <iostream>
#include <vector>


// command-line parsing
#include <@BASIS_INCLUDE_PREFIX@CmdLine.h>

// basic utilities
#include <@BASIS_INCLUDE_PREFIX@config.h>
#include <@BASIS_INCLUDE_PREFIX@assert.h>
#include <@BASIS_INCLUDE_PREFIX@except.h>
#include <@BASIS_INCLUDE_PREFIX@os.h>


/// @addtogroup BasisCxxUtilities
/// @{

namespace @BASIS_NAMESPACE_LOWER@ {

namespace @PROJECT_NAME_LOWER@ {


// ===========================================================================
// constants
// ===========================================================================

/// @brief The project name.
extern const char* PROJECT;
/// @brief The version string given as "<major>.<minor>.<patch>".
extern const char* VERSION;
/// @brief The major version number.
extern const unsigned int VERSION_MAJOR;
/// @brief The minor version number.
extern const unsigned int VERSION_MINOR;
/// @brief The patch number.
extern const unsigned int VERSION_PATCH;
/// @brief Complete version information as output by --version option.
extern const char* RELEASE;
/// @brief Default copyright of executables.
extern const char* COPYRIGHT;
/// @brief Default license of executables.
extern const char* LICENSE;
/// @brief Default contact to use for help output of executables.
extern const char* CONTACT;


namespace basis {


// ===========================================================================
// executable information
// ===========================================================================

/**
 * @brief Print contact information.
 *
 * @param [in] contact Name of contact. If @c NULL, CONTACT is used.
 */
void print_contact(const char* contact = NULL);

/**
 * @brief Print version information including copyright and license notices.
 *
 * @param [in] name      Name of executable. Should not be set programmatically
 *                       to the first argument of the @c_main() function, but
 *                       a string literal instead.
 * @param [in] version   Version of executable, e.g., release of project
 *                       this executable belongs to. Defaults to RELEASE.
 * @param [in] project   Name of project this executable belongs to.
 *                       If @c NULL, defaults to PROJECT. If an empty string,
 *                       no project information is printed.
 * @param [in] copyright The copyright notice, excluding the common prefix
 *                       "Copyright (c) " and suffix ". All rights reserved.".
 *                       If @c NULL, COPYRIGHT is used. If an empty string,
 *                       no copyright notice is printed.
 * @param [in] license   Information regarding licensing. If @c NULL, LICENSE
 *                       is used. If an empty string, no license information
 *                       is printed.
 */
void print_version(const char* name,
                   const char* version   = NULL,
                   const char* project   = NULL,
                   const char* copyright = NULL,
                   const char* license   = NULL);

/**
 * @brief Get UID of build target.
 *
 * The UID of a build target is its name prepended by a namespace identifier
 * which should be unique for each project.
 *
 * @param [in] name Name of build target.
 *
 * @returns UID of named build target.
 */
std::string get_target_uid(const std::string& name);

/**
 * @brief Determine whether a given build target is known.
 *
 * @param [in] name Name of build target.
 *
 * @returns Whether the named target is a known executable target.
 */
bool is_known_target(const std::string& name);

/**
 * @brief Get absolute path of executable file.
 *
 * This function determines the absolute file path of an executable. If no
 * arguments are given, the absolute path of this executable is returned.
 * If the command names a known executable build target, the absolute path to
 * the corresonding built (and installed) executable file is returned.
 * Otherwise, the named command is searched in the system @c PATH and its
 * absolute path returned if found. If the executable is not found, an
 * empty string is returned.
 *
 * @todo This function currently makes use of the which command implemented
 *       in Python and called as subprocess in order to search a command
 *       in the system @c PATH. This which command is part of BASIS and
 *       can also be used on Windows. However, a native C++ implementation
 *       would be desireable.
 *
 * @param [in] name Name of command or @c NULL.
 *
 * @returns Absolute path of executable or an empty string if not found.
 *          If @p name is @c NULL, the path of this executable is returned.
 *
 * @sa exename()
 * @sa exedir()
 */
std::string exepath(const std::string& name = std::string());

/**
 * @brief Get name of executable file.
 *
 * @note The name of the executable may or may not include the file name
 *       extension depending on the executable type and operating system.
 *       Hence, this function is neither an equivalent to
 *       os::path::basename(exepath()) nor os::path::filename(exepath()).
 *       In particular, on Windows, the .exe and .com extension is not
 *       included in the returned executable name.
 *
 * @param [in] name Name of command or @c NULL.
 *
 * @returns Name of executable file or an empty string if not found.
 *          If @p name is @c NULL, the name of this executable is returned.
 *
 * @sa exepath()
 */
std::string exename(const std::string& name = std::string());

/**
 * @brief Get directory of executable file.
 *
 * @param [in] name Name of command or @c NULL.
 *
 * @returns Absolute path of directory containing executable or an empty string if not found.
 *          If @p name is @c NULL, the directory of this executable is returned.
 *
 * @sa exepath()
 */
std::string exedir(const std::string& name = std::string());

// ===========================================================================
// package directories
// ===========================================================================

/**
 * @brief Get absolute path of installation directory.
 *
 * This function returns the absolute path of the installation prefix path.
 * If the installation was not moved after a "make install", the returned
 * directory corresponds to the value of the INSTALL_PREFIX CMake variable
 * as specified during the build of the executable file. Note, however,
 * that even when the installation tree was moved after the configuration
 * and build of the software, the correct path is returned as long as the
 * relative directory structure of the installation tree is maintained.
 * This is because the path is determined relative to the directory of the
 * executable itself, knowning in which path this executable is located
 * relative to the INSTALL_PREFIX.
 *
 * @note If the executable is executed from within the build tree, the
 *       returned path will not be correct. Therefore, only use this
 *       function when executing_in_build_tree() returns false. Otherwise,
 *       the configured absolute paths which are valid for the build tree
 *       have to be used. Note that the build tree is not supposed to be
 *       relocatable in any case as it is only a temporary directory tree
 *       and CMake requires it to be not moved anywhere else.
 *
 * @return Absolute path of top directory of installation tree.
 */
std::string get_installation_prefix();

/**
 * @brief Get absolute path of directory containing runtime executables.
 *
 * @return Absolute path of directory containing runtime executables.
 */
std::string bindir();

/**
 * @brief Get absolute path of directory containing auxiliary executables.
 *
 * @return Absolute path of directory containing auxiliary executables.
 */
std::string libexecdir();

/**
 * @brief Get absolute path of directory containing libraries.
 *
 * @return Absolute path of directory containing libraries.
 */
std::string libdir();

/**
 * @brief Get absolute path of directory containing auxiliary data.
 *
 * @return Absolute path of directory containing auxiliary data.
 */
std::string datadir();

// ===========================================================================
// command execution
// ===========================================================================

/**
 * @class SubprocessError
 * @brief Exception type thrown by execute_process().
 */
class SubprocessError : public std::exception
{
public:
    SubprocessError(const std::string& msg) : msg_(msg) {}
    ~SubprocessError() throw () {}

private:
    std::string msg_; ///< Error message.
}; // class SubprocessError

/**
 * @brief Convert array of arguments to quoted string.
 *
 * @param [in] args Array of arguments.
 *
 * @returns Double quoted string, i.e., string where arguments are separated
 *          by a space character and surrounded by double quotes if necessary.
 *          Double quotes within an argument are escaped with a backslash.
 *
 * @sa split_quoted_string()
 */
std::string to_quoted_string(const std::vector<std::string>& args);

/**
 * @brief Split quoted string.
 *
 * @param [in] args Quoted string of arguments.
 *
 * @returns Array of arguments.
 *
 * @sa to_quoted_string()
 */
std::vector<std::string> split_quoted_string(const std::string& args);

/**
 * @brief Execute command as subprocess.
 *
 * This function is a replacement for system() on Unix and is furthermore
 * less platform dependent. The first argument of the given command-line string
 * is mapped to an absolute executable file using get_executable_path() if the
 * given first argument is a know build target name. Otherwise, the command-line
 * is used unmodified.
 *
 * @param [in] cmd         Command-line given as double quoted string. Arguments
 *                         containing whitespaces have to be quoted using double
 *                         quotes. Use a backslash (\\) to escape double quotes
 *                         inside an argument as well as to escape a backslash
 *                         itself (required if backslash at end of double quoted
 *                         argument, e.g., "this argument \\").
 * @param [in]  quiet      Turns off output of stdout of child process to stdout
 *                         of parent process.
 * @param [out] out        Output stream where command output is written to.
 * @param [in]  allow_fail If true, no exception is thrown if the exit code
 *                         of the child process is non-zero. Otherwise,
 *                         a SubprocessException object is thrown in that case.
 * @param [in]  verbose    Verbosity of output messages. Does not affect
 *                         verbosity of executed command.
 * @param [in]  simulate   Whether to simulate command execution only.
 *
 * @returns Exit code of command or -1 if subprocess creation failed.
 *
 * @throws SubprocessException If subprocess creation failed or command returned
 *                             a non-zero exit code while @p allow_fail is false.
 */
int execute_process(const std::string& cmd,
                    bool               quiet      = false,
                    // attention: stdout is a macro defined by windows.h
                    std::ostream*      out        = NULL,
                    bool               allow_fail = false,
                    int                verbose    = 0,
                    bool               simulate   = false);

/**
 * @brief Execute command as subprocess.
 *
 * This function is a replacement for system() on Unix and is furthermore
 * less platform dependent. The first argument of the given command-line string
 * is mapped to an absolute executable file using get_executable_path() if the
 * given first argument is a know build target name. Otherwise, the command-line
 * is used unmodified.
 *
 * @param [in,out] args       Command-line given as argument vector. The first
 *                            argument has to be either a build target name or the
 *                            name/path of the command to execute. Note that as a
 *                            side effect, the first argument of the input vector
 *                            is replaced by the absolute path of the actual
 *                            executable file if applicable.
 * @param [in]     quiet      Turns off output of stdout of child process to
 *                            stdout of parent process.
 * @param [out]    out        Output stream where command output is written to.
 * @param [in]     allow_fail If true, no exception is thrown if the exit code
 *                            of the child process is non-zero. Otherwise,
 *                            a SubprocessException object is thrown in that case.
 * @param [in]     verbose    Verbosity of output messages. Does not affect
 *                            verbosity of executed command.
 * @param [in]     simulate   Whether to simulate command execution only.
 *
 * @returns Exit code of command or -1 if subprocess creation failed.
 *
 * @throws SubprocessException If subprocess creation failed or command returned
 *                             a non-zero exit code while @p allow_fail is false.
 */
int execute_process(std::vector<std::string>& args,
                    bool                      quiet      = false,
                    // attention: stdout is a macro defined by windows.h
                    std::ostream*             out        = NULL,
                    bool                      allow_fail = false,
                    int                       verbose    = 0,
                    bool                      simulate   = false);


/// @}
// end of Doxygen group


} // namespace basis

} // namespace @PROJECT_NAME_LOWER@

} // namespace @BASIS_NAMESPACE_LOWER@


#endif // _@BASIS_NAMESPACE_UPPER@_@PROJECT_NAME_UPPER@_BASIS_H
