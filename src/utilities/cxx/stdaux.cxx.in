/**
 * @file  stdaux.cxx
 * @brief Implementation of standard auxiliary functions.
 *
 * @note The file stdaux.cxx is automatically generated by BASIS from the
 *       template file stdaux.cxx.in which is part of BASIS.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 *
 * @ingroup CppUtilities
 */


#include <iostream>
#include <cassert>

#include <sbia/basis/path.h>
#include "ExecutableTargetInfo.h"
#include "stdaux.h"


using namespace std;
using namespace SBIA_BASIS_NAMESPACE;


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN


// ===========================================================================
// version / contact
// ===========================================================================

// ---------------------------------------------------------------------------
void print_version(const char* name, const char* copyright, const char* license)
{
    if (name) cout << name;
    else      cout << get_executable_name();
    cout << " (" << cProjectName << ") version " << cVersion;
    if (cRevision > 0) cout << " (revision " << cRevision << ")";
    cout << endl;
    if (copyright == NULL) {
        cout << "Copyright (c) University of Pennsylvania. All rights reserved." << endl;
    } else if (*copyright != '\0') {
        cout << copyright << endl;
    }
    if (license == NULL) {
        cout << "See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file." << endl;
    } else if (*license != '\0') {
        cout << license << endl;
    }
}

// ---------------------------------------------------------------------------
void print_contact(const char* contact)
{
    cout << "Contact:" << endl;
    if (contact) cout << "  " << contact << endl;
    else         cout << "  SBIA Group <sbia-software at uphs.upenn.edu>" << endl;
}

// ===========================================================================
// installation directories
// ===========================================================================

// ---------------------------------------------------------------------------
bool executing_in_build_tree()
{
    // get executable path relative to top directory of build tree
    string rel_path = to_relative_path(cBuildRoot, get_executable_directory());
    // return whether executable directory is inside the build tree or not
    return !(rel_path == "" || rel_path == "." ||
            (rel_path.substr(0, 2) == ".." && (rel_path.size() == 2 || rel_path[2] == '/')));
}

// ---------------------------------------------------------------------------
string get_installation_prefix()
{
#ifdef LIBEXEC
    return join_paths(get_executable_directory(), cLibexecPathPrefix);
#else
    return join_paths(get_executable_directory(), cRuntimePathPrefix);
#endif
}

// ---------------------------------------------------------------------------
string get_runtime_directory()
{
    if (executing_in_build_tree()) {
        return cRuntimeBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cRuntimePath);
    }
}

// ---------------------------------------------------------------------------
string get_libexec_directory()
{
    if (executing_in_build_tree()) {
        return cLibexecBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cLibexecPath);
    }
}

// ---------------------------------------------------------------------------
string get_library_directory()
{
    if (executing_in_build_tree()) {
        return cLibraryBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cLibraryPath);
    }
}

// ---------------------------------------------------------------------------
string get_data_directory()
{
    if (executing_in_build_tree()) {
        return cDataBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cDataPath);
    }
}

// ===========================================================================
// executable file path of other build targets
// ===========================================================================

// ---------------------------------------------------------------------------
string get_executable_path(const std::string& target)
{
    // get executable target information instance
    const ExecutableTargetInfo &info = ExecutableTargetInfo::instance();
    // get name of executable and check if target name is known
    string exec_name = info.get_executable_name(target);
    // is this target known?
    if (exec_name.empty()) return "";
    // prepend either build tree directory or installation directory
    if (executing_in_build_tree()) {
        return join_paths(info.get_build_directory(target), exec_name);
    } else {
        return join_paths(info.get_installation_directory(target), exec_name);
    }
}

// ===========================================================================
// subprocess execution
// ===========================================================================

// ---------------------------------------------------------------------------
int execute_process(const string& cmd)
{
    string cmdline;
    string cmdname;
    string cmdargs;

    // extract first argument
    const char whitespace[] = " \f\n\r\t\v";
    for (string::size_type i = 0, j = 0; (j != string::npos) && (i < cmd.size()); i++) {
        if (cmd[i] == '\"') {
            j = i;
            do {
                j = cmd.find('\"', ++j);
            } while (j != string::npos && cmd[j - 1] == '\\');
            cmdname = cmd.substr(i + 1, j - i);
            cmdargs = cmd.substr(j + 1);
            break;
        } else if (!isspace(cmd[i])) {
            j = cmd.find_first_not_of(whitespace, i);
            i = j - 1;
        } else {
            j = i;
            do {
                j = cmd.find_first_of(whitespace, ++j);
            } while ((j != string::npos) && (cmd[j - 1] == '\\'));
            cmdname = cmd.substr(i, j - i);
            cmdargs = cmd.substr(j);
            break;
        }
        i++;
    }

    // map build target name to executable file path
    cmdline = get_executable_path(cmdname);
    if (cmdline.empty()) cmdline  = cmd;
    else {
        cmdline.insert(0, 1, '\"');
        cmdline += "\" ";
        cmdline += cmdargs;
    }
 
    // execute command
    return Subprocess::call(cmdline);
}

// ---------------------------------------------------------------------------
int execute_process(Subprocess::CommandLine& cmd)
{
    assert(cmd.size() > 0);
    string tmp = get_executable_path(cmd[0].c_str());
    if (!tmp.empty()) cmd[0] = tmp;
    return Subprocess::call(cmd);
}


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
