/**
 * @file  stdaux.cxx
 * @brief Implementation of standard auxiliary functions.
 *
 * @note The file stdaux.cxx is automatically generated by BASIS from the
 *       template file stdaux.cxx.in which is part of BASIS.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 *
 * @ingroup CppUtilities
 */


#include <iostream>

#include <sbia/basis/path.h>
#include <sbia/basis/subprocess.h>
#include "ExecutableTargetInfo.h"
#include "stdaux.h"


using namespace std;
using namespace SBIA_BASIS_NAMESPACE;


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN


// ===========================================================================
// version / contact
// ===========================================================================

// ***************************************************************************
void print_version(const char* name, const char* copyright, const char* license)
{
    if (name) cout << name;
    else      cout << get_executable_name();
    cout << " (" << cProjectName << ") version " << cVersion;
    if (cRevision > 0) cout << " (revision " << cRevision << ")";
    cout << endl;
    if (copyright == NULL) {
        cout << "Copyright (c) University of Pennsylvania. All rights reserved." << endl;
    } else if (*copyright != '\0') {
        cout << copyright << endl;
    }
    if (license == NULL) {
        cout << "See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file." << endl;
    } else if (*license != '\0') {
        cout << license << endl;
    }
}

// ***************************************************************************
void print_contact(const char* contact)
{
    cout << "Contact:" << endl;
    if (contact) cout << "  " << contact << endl;
    else         cout << "  SBIA Group <sbia-software at uphs.upenn.edu>" << endl;
}

// ===========================================================================
// installation directories
// ===========================================================================

// ***************************************************************************
bool executing_in_build_tree()
{
    // get executable path relative to top directory of build tree
    string rel_path = to_relative_path(cBuildRoot, get_executable_directory());
    // return whether executable directory is inside the build tree or not
    return !(rel_path == "" || rel_path == "." ||
            (rel_path.substr(0, 2) == ".." && (rel_path.size() == 2 || rel_path[2] == '/')));
}

// ***************************************************************************
string get_installation_prefix()
{
#ifdef LIBEXEC
    return join_paths(get_executable_directory(), cLibexecPathPrefix);
#else
    return join_paths(get_executable_directory(), cRuntimePathPrefix);
#endif
}

// ***************************************************************************
string get_runtime_directory()
{
    if (executing_in_build_tree()) {
        return cRuntimeBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cRuntimePath);
    }
}

// ***************************************************************************
string get_libexec_directory()
{
    if (executing_in_build_tree()) {
        return cLibexecBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cLibexecPath);
    }
}

// ***************************************************************************
string get_library_directory()
{
    if (executing_in_build_tree()) {
        return cLibraryBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cLibraryPath);
    }
}

// ***************************************************************************
string get_data_directory()
{
    if (executing_in_build_tree()) {
        return cDataBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cDataPath);
    }
}

// ===========================================================================
// executable file path of other build targets
// ===========================================================================

// ***************************************************************************
string get_executable_path(const char* target)
{
    // get executable target information instance
    const ExecutableTargetInfo &info = ExecutableTargetInfo::instance();
    // get name of executable and check if target name is known
    string exec_name = info.get_executable_name(target);
    // is this target known?
    if (exec_name.empty()) return "";
    // prepend either build tree directory or installation directory
    if (executing_in_build_tree()) {
        return join_paths(info.get_build_directory(target), exec_name);
    } else {
        return join_paths(info.get_installation_directory(target), exec_name);
    }
}

// ===========================================================================
// subprocess execution
// ===========================================================================

int execute_process(const char* target, const char* arguments)
{
    string cmd = get_executable_path(target);
    if (cmd.empty()) cmd = target;
    cmd += " ";
    cmd += arguments;
    return SubProcess::call(cmd);
}


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
