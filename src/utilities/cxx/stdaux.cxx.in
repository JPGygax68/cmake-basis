/**
 * @file  stdaux.cxx
 * @brief Implementation of standard auxiliary functions.
 *
 * @note The file stdaux.cxx is automatically generated by BASIS from the
 *       template file stdaux.cxx.in which is part of BASIS.
 *
 * Copyright (c) 2011, University of Pennsylvania. All rights reserved.<br />
 * See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 */

#include <iostream>

#include <sbia/basis/config.h>      // cProjectName, cVersionAndRevision
#include <sbia/basis/path.h>
#include <sbia/basis/except.h>
#include <sbia/basis/assert.h>
#include <sbia/basis/subprocess.h>
#include "ExecutableTargetInfo.h"

#include "stdaux.h"


using namespace std;


namespace sbia
{

namespace basis
{


// ===========================================================================
// version / contact
// ===========================================================================

// ---------------------------------------------------------------------------
void print_version(const char* name, const char* copyright, const char* license)
{
    assert(name != NULL);
    cout << name << " (" << cProjectName << ") " << cVersionAndRevision << endl;
    if (copyright == NULL) {
        cout << "Copyright (c) University of Pennsylvania. All rights reserved." << endl;
    } else if (*copyright != '\0') {
        cout << copyright << endl;
    }
    if (license == NULL) {
        cout << "See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file." << endl;
    } else if (*license != '\0') {
        cout << license << endl;
    }
}

// ---------------------------------------------------------------------------
void print_contact(const char* contact)
{
    cout << "Contact:" << endl;
    if (contact) cout << "  " << contact << endl;
    else         cout << "  SBIA Group <sbia-software at uphs.upenn.edu>" << endl;
}

// ===========================================================================
// installation directories
// ===========================================================================

// ---------------------------------------------------------------------------
bool executing_in_build_tree()
{
    // get executable path relative to top directory of build tree
    string rel_path = to_relative_path(cBuildRoot, get_executable_directory());
    // return whether executable directory is inside the build tree or not
    return !(rel_path == "" || rel_path == "." ||
            (rel_path.substr(0, 2) == ".." && (rel_path.size() == 2 || rel_path[2] == '/')));
}

// ---------------------------------------------------------------------------
string get_installation_prefix()
{
#ifdef LIBEXEC
    return join_paths(get_executable_directory(), cLibexecPathPrefix);
#else
    return join_paths(get_executable_directory(), cRuntimePathPrefix);
#endif
}

// ---------------------------------------------------------------------------
string get_runtime_directory()
{
    if (executing_in_build_tree()) {
        return cRuntimeBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cRuntimePath);
    }
}

// ---------------------------------------------------------------------------
string get_libexec_directory()
{
    if (executing_in_build_tree()) {
        return cLibexecBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cLibexecPath);
    }
}

// ---------------------------------------------------------------------------
string get_library_directory()
{
    if (executing_in_build_tree()) {
        return cLibraryBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cLibraryPath);
    }
}

// ---------------------------------------------------------------------------
string get_data_directory()
{
    if (executing_in_build_tree()) {
        return cDataBuildPath;
    } else {
        return join_paths(get_installation_prefix(), cDataPath);
    }
}

// ===========================================================================
// executable file path of other build targets
// ===========================================================================

// ---------------------------------------------------------------------------
string get_executable_path(const string& target)
{
    // get executable target information instance
    const ExecutableTargetInfo& info = ExecutableTargetInfo::instance();
    // get name of executable and check if target name is known
    string exec_name = info.get_executable_name(target);
    // is this target known?
    if (exec_name.empty()) return "";
    // prepend either build tree directory or installation directory
    if (executing_in_build_tree()) {
        return join_paths(info.get_build_directory(target), exec_name);
    } else {
        return join_paths(info.get_installation_directory(target), exec_name);
    }
}

// ===========================================================================
// command execution
// ===========================================================================

// ---------------------------------------------------------------------------
int execute_process(const string& cmd, bool quiet, ostream* out,
                    bool allow_fail, int verbose, bool simulate)
{
    vector<string> args = Subprocess::split(cmd);
    return execute_process(args, quiet, out, allow_fail, verbose, simulate);
}

// ---------------------------------------------------------------------------
int execute_process(vector<string>& args, bool quiet, ostream* out,
                    bool allow_fail, int verbose, bool simulate)
{
    if (args.empty() || args[0].empty()) {
        BASIS_THROW(SubprocessException, "execute_process(): No command specified");
    }
    // map build target name to executable file path
    string exec_path = get_executable_path(args[0]);
    // prepend absolute path of found executable
    if (!exec_path.empty()) args[0] = exec_path;
    // some verbose output
    if (verbose > 0) {
        cout << "$ " << Subprocess::tostring(args);
        if (simulate) cout << " (simulated)";
        cout << endl;
    }
    // execute command
    char buf[1024];
    int  n;
    int status = 0;
    Subprocess p;
    if (!p.popen(args, Subprocess::RM_NONE, Subprocess::RM_PIPE, Subprocess::RM_PIPE)) {
        BASIS_THROW(SubprocessException, "execute_process(): Failed to create subprocess");
    }
    // read child's stdout (blocking)
    if (!quiet || out != NULL) {
        while ((n = p.read(buf, 1023)) > 0) {
            buf[n] = '\0';
            if (!quiet) {
                cout << buf;
                cout.flush();
            }
            if (out) *out << buf;
        }
    }
    // wait for child process
    if (!p.wait()) {
        BASIS_THROW(SubprocessException, "execute_process(): Failed to wait for subprocess");
    }
    // write error messages to stderr of parent process
    while ((n = p.read(buf, 1023, true)) > 0) {
        buf[n] = '\0';
        cerr << buf;
    }
    // get exit code
    status = p.returncode();
    // if command failed, throw an exception
    if (status != 0 && !allow_fail) {
        BASIS_THROW(SubprocessException, "Command " << Subprocess::tostring(args) << " failed");
    }
    return status;
}


} // namespace basis

} // namespace sbia
