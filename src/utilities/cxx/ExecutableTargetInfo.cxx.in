/**
 * @file  ExecutableTargetInfo.cxx
 * @brief Implementation of ExecutableTargetInfo module.
 *
 * @note The file ExecutableTargetInfo.cxx is automatically generated by BASIS
 *       from the template file ExecutableTargetInfo.cxx.in which is part of BASIS.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 *
 * @ingroup BasisCxxUtilities
 */


#include <sbia/basis/path.h>

#include "ExecutableTargetInfo.h"


using namespace std;
using namespace SBIA_BASIS_NAMESPACE;


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN

namespace basis {


// ===========================================================================
// static members
// ===========================================================================

ExecutableTargetInfo* ExecutableTargetInfo::instance_ = NULL;

// ===========================================================================
// construction / destruction
// ===========================================================================

ExecutableTargetInfo::ExecutableTargetInfo()
{
    @EXECUTABLE_TARGET_INFO@
}

ExecutableTargetInfo::~ExecutableTargetInfo()
{
}

// ===========================================================================
// public interface
// ===========================================================================

// ---------------------------------------------------------------------------
const ExecutableTargetInfo& ExecutableTargetInfo::instance()
{
    // TODO make this thread-safe!
    if (!instance_) instance_ = new ExecutableTargetInfo();
    return *instance_;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_target_uid(const string& target) const
{
    // empty(, invalid) target name remains unchanged
    if (target.empty()) return "";
    // in case of a leading namespace separator, do not modify target name
    if (target.at(0) == '.') return target;
    // project namespace
    string prefix = string("@PROJECT_NAMESPACE_CMAKE@");
    // try prepending namespace or parts of it until target is known
    for (;;) {
        if (exec_names_.find(prefix + "." + target) != exec_names_.end()) {
            return prefix + "." + target;
        }
        string::size_type pos = prefix.rfind('.');
        if (pos == string::npos) break;
        prefix = prefix.substr(0, pos);
    }
    // otherwise, return target name unchanged
    return target;
}

// ---------------------------------------------------------------------------
bool ExecutableTargetInfo::is_known_target(const string& target) const
{
    if (target.empty()) return false;
    string uid;
    if (target.at(0) == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    return exec_names_.find(get_target_uid(target)) != exec_names_.end();
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_executable_name(const string& target) const
{
    if (target.empty()) return false;
    string uid;
    if (target.at(0) == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = exec_names_.find(uid);
    if (it == exec_names_.end ()) return "";
    return it->second;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_build_directory(const string& target) const
{
    if (target.empty()) return false;
    string uid;
    if (target.at(0) == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = build_dirs_.find(uid);
    if (it == build_dirs_.end()) return "";
    return it->second;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_installation_directory(const string& target) const
{
    if (target.empty()) return false;
    string uid;
    if (target.at(0) == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = install_dirs_.find(uid);
    if (it == install_dirs_.end()) return "";
#ifdef LIBEXEC
    return join_paths(join_paths(get_executable_directory(), cLibexecPathPrefix), it->second);
#else
    return join_paths(join_paths(get_executable_directory(), cRuntimePathPrefix), it->second);
#endif
}


} // namespace basis

SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
