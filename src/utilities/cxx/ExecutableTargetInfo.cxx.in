/**
 * @file  ExecutableTargetInfo.cxx
 * @brief Implementation of ExecutableTargetInfo module.
 *
 * @note The file ExecutableTargetInfo.cxx is automatically generated by BASIS
 *       from the template file ExecutableTargetInfo.cxx.in which is part of BASIS.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 *
 * @ingroup CppUtilities
 */


#include <sbia/basis/path.h>

#include "ExecutableTargetInfo.h"


using namespace std;
using namespace SBIA_BASIS_NAMESPACE;


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN


// ===========================================================================
// static members
// ===========================================================================

ExecutableTargetInfo* ExecutableTargetInfo::instance_ = NULL;

// ===========================================================================
// construction / destruction
// ===========================================================================

// ***************************************************************************
ExecutableTargetInfo::ExecutableTargetInfo()
{
    @EXECUTABLE_TARGET_INFO@
}

// ***************************************************************************
ExecutableTargetInfo::~ExecutableTargetInfo()
{
}

// ===========================================================================
// public interface
// ===========================================================================

// ---------------------------------------------------------------------------
const ExecutableTargetInfo& ExecutableTargetInfo::instance()
{
    // TODO make this thread-safe!
    if (!instance_) instance_ = new ExecutableTargetInfo();
    return *instance_;
}

// ***************************************************************************
string ExecutableTargetInfo::get_target_uid(const string& target) const
{
    if (target.empty()) return "";
    if (exec_names_.find(target) == exec_names_.end() && target.find("::") == string::npos) {
        return cProjectNameLower + "::" + target;
    }
    return target;
}

// ***************************************************************************
bool ExecutableTargetInfo::is_known_target(const string& target) const
{
    return exec_names_.find(get_target_uid(target)) != exec_names_.end();
}

// ***************************************************************************
string ExecutableTargetInfo::get_executable_name(const string& target) const
{
    string uid = get_target_uid(target);
    MapIterator it = exec_names_.find(uid);
    if (it == exec_names_.end ()) return "";
    return it->second;
}

// ***************************************************************************
string ExecutableTargetInfo::get_build_directory(const string& target) const
{
    string uid = get_target_uid(target);
    MapIterator it = build_dirs_.find(uid);
    if (it == build_dirs_.end()) return "";
    return it->second;
}

// ***************************************************************************
string ExecutableTargetInfo::get_installation_directory(const string& target) const
{
    string uid = get_target_uid(target);
    MapIterator it = install_dirs_.find(uid);
    if (it == install_dirs_.end()) return "";
#ifdef LIBEXEC
    return join_paths(join_paths(get_executable_directory(), cLibexecPathPrefix), it->second);
#else
    return join_paths(join_paths(get_executable_directory(), cRuntimePathPrefix), it->second);
#endif
}


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
