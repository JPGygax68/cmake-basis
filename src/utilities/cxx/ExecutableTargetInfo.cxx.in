/**
 * @file  ExecutableTargetInfo.cxx
 * @brief Implementation of ExecutableTargetInfo module.
 *
 * @note The file ExecutableTargetInfo.cxx is automatically generated by BASIS
 *       from the template file ExecutableTargetInfo.cxx.in which is part of BASIS.
 *
 * Copyright (c) 2011, University of Pennsylvania. All rights reserved.<br />
 * See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 */


#include <sbia/basis/path.h>
#include <@INCLUDE_PREFIX@config.h> // cLibexecPathPrefix, cRuntimePathPrefix

#include "ExecutableTargetInfo.h"


// acceptable in .cxx file
using namespace std;


namespace sbia
{

namespace basis
{


// ===========================================================================
// construction / destruction
// ===========================================================================

ExecutableTargetInfo::ExecutableTargetInfo()
{
    @EXECUTABLE_TARGET_INFO@
}

ExecutableTargetInfo::~ExecutableTargetInfo()
{
}

// ===========================================================================
// public interface
// ===========================================================================

// ---------------------------------------------------------------------------
const ExecutableTargetInfo& ExecutableTargetInfo::instance()
{
    static ExecutableTargetInfo instance;
    return instance;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_target_uid(const string& target) const
{
    // empty(, invalid) target name remains unchanged
    if (target.empty()) return "";
    // in case of a leading namespace separator, do not modify target name
    if (target[0] == '.') return target;
    // project namespace
    string prefix = string("@PROJECT_NAMESPACE_CMAKE@");
    // try prepending namespace or parts of it until target is known
    for (;;) {
        if (_exec_names.find(prefix + "." + target) != _exec_names.end()) {
            return prefix + "." + target;
        }
        string::size_type pos = prefix.rfind('.');
        if (pos == string::npos) break;
        prefix = prefix.substr(0, pos);
    }
    // otherwise, return target name unchanged
    return target;
}

// ---------------------------------------------------------------------------
bool ExecutableTargetInfo::is_known_target(const string& target) const
{
    if (target.empty()) return false;
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    return _exec_names.find(uid) != _exec_names.end();
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_executable_name(const string& target) const
{
    if (target.empty()) return "";
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = _exec_names.find(uid);
    if (it == _exec_names.end ()) return "";
    return it->second;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_build_directory(const string& target) const
{
    if (target.empty()) return "";
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = _build_dirs.find(uid);
    if (it == _build_dirs.end()) return "";
#if defined CMAKE_INTDIR
    // this subdirectory is used by CMake generators for IDEs such as Visual Studio
    return join_paths(it->second, CMAKE_INTDIR);
#else
    return it->second;
#endif
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_installation_directory(const string& target) const
{
    if (target.empty()) return "";
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = _install_dirs.find(uid);
    if (it == _install_dirs.end()) return "";
#ifdef LIBEXEC
    return join_paths(join_paths(get_executable_directory(), cLibexecPathPrefix), it->second);
#else
    return join_paths(join_paths(get_executable_directory(), cRuntimePathPrefix), it->second);
#endif
}


} // namespace basis

} // namespace sbia
