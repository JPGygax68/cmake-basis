/**
 * @file  stdaux.cc
 * @brief Implementation of standard auxiliary functions.
 *
 * @note The file stdaux.cc is automatically generated by BASIS from the
 *       template file stdaux.cc.in which is part of BASIS.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 *
 * @ingroup CppUtilities
 */


#include <iostream>

#include <sbia/basis/path.h>
#include "ExecutableTargetInfo.h"

#include "stdaux.h"


using namespace std;


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN


// ===========================================================================
// version / contact
// ===========================================================================

// ***************************************************************************
void PrintVersion (const char *name, const char *copyright, const char *license)
{
    if (name) cout << name;
    else      cout << GetExecutableName ();
    cout << " (" << cProjectName << ") version " << cVersion;
    if (cRevision > 0) cout << " (revision " << cRevision << ")";
    cout << endl;
    if (copyright == NULL) {
        cout << "Copyright (c) University of Pennsylvania. All rights reserved." << endl;
    } else if (*copyright != '\0') {
        cout << copyright << endl;
    }
    if (license == NULL) {
        cout << "See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file." << endl;
    } else if (*license != '\0') {
        cout << license << endl;
    }
}

// ***************************************************************************
void PrintContact (const char *contact)
{
    cout << "Contact:" << endl;
    if (contact) cout << "  " << contact << endl;
    else         cout << "  SBIA Group <sbia-software at uphs.upenn.edu>" << endl;
}

// ===========================================================================
// installation directories
// ===========================================================================

// ***************************************************************************
bool ExecutingInBuildTree ()
{
    // get executable path relative to top directory of build tree
    string relPath = ToRelativePath (cBuildRoot, GetExecutableDirectory ());
    // return whether executable directory is inside the build tree or not
    return !(relPath == "" || relPath == "." ||
            (relPath.substr (0, 2) == ".." && (relPath.size () == 2 || relPath [2] == '/')));
}

// ***************************************************************************
string GetInstallationPrefix ()
{
#ifdef LIBEXEC
    return JoinPaths (GetExecutableDirectory (), cLibexecPathPrefix);
#else
    return JoinPaths (GetExecutableDirectory (), cRuntimePathPrefix);
#endif
}

// ***************************************************************************
string GetRuntimeDirectory ()
{
    if (ExecutingInBuildTree ()) {
        return cRuntimeBuildPath;
    } else {
        return JoinPaths (GetInstallationPrefix (), cRuntimePath);
    }
}

// ***************************************************************************
string GetLibexecDirectory ()
{
    if (ExecutingInBuildTree ()) {
        return cLibexecBuildPath;
    } else {
        return JoinPaths (GetInstallationPrefix (), cLibexecPath);
    }
}

// ***************************************************************************
string GetLibraryDirectory ()
{
    if (ExecutingInBuildTree ()) {
        return cLibraryBuildPath;
    } else {
        return JoinPaths (GetInstallationPrefix (), cLibraryPath);
    }
}

// ***************************************************************************
string GetDataDirectory ()
{
    if (ExecutingInBuildTree ()) {
        return cDataBuildPath;
    } else {
        return JoinPaths (GetInstallationPrefix (), cDataPath);
    }
}

// ===========================================================================
// executable file path of other build targets
// ===========================================================================

// ***************************************************************************
string GetExecutablePath (const char *target)
{
    // get executable target information instance
    const ExecutableTargetInfo &info = ExecutableTargetInfo::GetInstance ();
    // get name of executable and check if target name is known
    string execName = info.GetExecutableName (target);
    // is this target known?
    if (execName.empty ()) return "";
    // prepend either build tree directory or installation directory
    if (ExecutingInBuildTree ()) {
        return JoinPaths (info.GetBuildDirectory (target), execName);
    } else {
        return JoinPaths (info.GetInstallationDirectory (target), execName);
    }
}


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
