/**
 * @file  basis.cxx
 * @brief BASIS Utilities of @PROJECT_NAME@ package.
 *
 * @note The basis.cxx module was automatically generated by BASIS from the
 *       template file basis.cxx.in which is part of the BASIS installation.
 *
 * Copyright (c) 2011, 2012 University of Pennsylvania. All rights reserved.<br />
 * See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 */

#include <map>

#include <@BASIS_INCLUDE_PREFIX@subprocess.h>
#include <@BASIS_NAMESPACE_LOWER@/@PROJECT_NAME_LOWER@/basis.h>


// acceptable in .cxx file
using namespace std;
using namespace sbia::basis;


namespace @BASIS_NAMESPACE_LOWER@ {

namespace @PROJECT_NAME_LOWER@ {


// ===========================================================================
// constants
// ===========================================================================

// ---------------------------------------------------------------------------
// project attributes
const char* PROJECT = "@PROJECT_NAME@";
const char* VERSION = "@PROJECT_VERSION@";
const char* RELEASE = "@PROJECT_RELEASE@";

const unsigned int VERSION_MAJOR = @PROJECT_VERSION_MAJOR@;
const unsigned int VERSION_MINOR = @PROJECT_VERSION_MINOR@;
const unsigned int VERSION_PATCH = @PROJECT_VERSION_PATCH@;

const char* COPYRIGHT = "University of Pennsylvania";
const char* LICENSE   = "See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.";
const char* CONTACT   = "SBIA Group <sbia-software at uphs.upenn.edu>";


namespace basis {


// ===========================================================================
// class: ExecutableTargetInfo (declaration)
// ===========================================================================

// The definition of the class methods can be found at the end of this file.

/**
 * @brief Provides information about executable build targets.
 *
 * Within source code of a BASIS project, other SBIA executables are called
 * only indirectly using the build target name which must be fixed and unique
 * within the lab. The name of the output executable file of these targets may
 * however vary and be finally set by BASIS, for example, depending on
 * whether the project is build as part of a superproject or not. Therefore,
 * each BASIS CMake function may adjust the output name in order to resolve
 * name conflicts with other targets or SBIA executables.
 *
 * The idea is that a target name is supposed to be stable and known to the
 * developer as soon as the target is added to a CMakeLists.txt file, while
 * the name of the actual executable file is not known a priori as it is set
 * by the BASIS CMake functions during the configure step. Thus, the developer
 * should not rely on a particular name of the executable file. Instead, they
 * can rely on the name of the corresponding build target which was chosen by
 * themselves when adding the target to the build configuration.
 *
 * In order to get the actual file path of the built executable file, the
 * function get_executable_path() is provided by the stdaux.h module.
 * This function uses the static singleton instance of this class in order to
 * map the given build target name to the name of the built and optionally
 * installed executable. The code which initializes the required maps is
 * generated automatically during the configuration of the build system.
 *
 * @note This class is not intended to be subclassed.
 *
 * @sa get_executable_path()
 */
class ExecutableTargetInfo
{
    // -----------------------------------------------------------------------
    // typedefs
private:

    typedef std::map <std::string, std::string> MapType;
    typedef MapType::const_iterator             MapIterator;

    // -----------------------------------------------------------------------
    // construction / destruction
private:

    /**
     * @brief Constructor.
     *
     * Initializes the data members. The initialization code is in particular
     * generated by BASIS during the configuration of the build system.
     */
    ExecutableTargetInfo();

    /// @brief Destructor.
    ~ExecutableTargetInfo() {}

    // -----------------------------------------------------------------------
    // public interface
public:

    /**
     * @brief Get static instance of this module.
     *
     * @attention This method is not thread-safe!
     *
     * @return Static instance of this class.
     */
    static const ExecutableTargetInfo& instance();

    /**
     * @brief Get UID of build target.
     *
     * In order to be able to distinguish build targets with identical name
     * but which are built as part of different BASIS projects, the UID of
     * a build target is composed of the build target name as given as
     * argument to the basis_add_* CMake functions and a namespace identifier
     * (i.e., the project name in lowercase letters). If the specified build
     * target name is neither known by this module nor a build target UID yet,
     * this method prepends the namespace identifier corresponding to the
     * project this module was built from, assuming that the caller refers
     * to another target within the same project.
     *
     * @param [in] target Name/UID of build target.
     *
     * @returns UID of build target.
     */
    std::string get_target_uid(const std::string& target) const;

    /**
     * @brief Determine whether a given build target is known.
     *
     * @param [in] target Name/UID of build target.
     *
     * @returns Whether the given build target is known by this module.
     */
    bool is_known_target(const std::string& target) const;

    /**
     * @brief Get name of executable file without path.
     *
     * @param [in] target Name/UID of build target.
     *
     * @return Name of built executable file without path.
     */
    std::string get_executable_name(const std::string& target) const;

    /**
     * @brief Get absolute path of output directory of executable in build tree.
     *
     * @param [in] target Name/UID of build target.
     *
     * @return Absolute path of build tree directory where built executable is
     *         located or an empty string if build target is not known.
     */
    std::string get_build_directory(const std::string& target) const;

    /**
     * @brief Get absolute path of directory where built executable is installed.
     *
     * @param [in] target Name/UID of build target.
     *
     * @return Absolute path of executable's installation directory or
     *         an empty string if build target is not known.
     */
    std::string get_installation_directory(const std::string& target) const;

    // -----------------------------------------------------------------------
    // unsupported methods
private:

    /**
     * @brief Copy constructor.
     *
     * @note Intentionally not implemented.
     */
    ExecutableTargetInfo(const ExecutableTargetInfo&);

    /**
     * @brief Assignment operator.
     *
     * @note Intentionally not implemented.
     */
    void operator=(const ExecutableTargetInfo&);

    // -----------------------------------------------------------------------
    // members
private:

    /// Maps build target names to executable file names.
    MapType _exec_names;
    /// Maps build target names to output directories in build tree.
    MapType _build_dirs;
    /// Maps build target names to installation directories relative to
    /// installation prefix as returned by GetInstallationPrefix().
    MapType _install_dirs;

}; // class ExecutableTargetInfo

// ===========================================================================
// executable information
// ===========================================================================

// ---------------------------------------------------------------------------
void print_contact(const char* contact)
{
    if (contact == NULL) contact = CONTACT;
    cout << "Contact:\n  " << contact << endl;
}

// ---------------------------------------------------------------------------
void print_version(const char* name, const char* version, const char* project, const char* copyright, const char* license)
{
    assert(name != NULL);
    if (version   == NULL) version   = RELEASE;
    if (project   == NULL) project   = PROJECT;
    if (copyright == NULL) copyright = COPYRIGHT;
    if (license   == NULL) license   = LICENSE;
    cout << name;
    if (*project) cout << " (" << project << ")";
    cout << " " << version << endl;
    if (*copyright) cout << "Copyright (c) " << copyright << ". All rights reserved." << endl;
    if (*license) cout << license << endl;
}

/**
 * @brief Whether the executable was executed from within the build tree.
 *
 * @return Whether the executable was executed from within the build tree.
 */
inline bool executing_in_build_tree()
{
    // get executable path relative to top directory of build tree
    string rel_path = os::path::relpath(
            // directory of this executable
            os::exedir(),
            // The following path is the absolute path of the top directory of the build
            // tree in which the software was built. It can be used to determine whether
            // an executable is executing from within the build tree rather than an
            // installation. Given that we tend to build software in a directory with the
            // prefix "-build", but never choose such directory for the installation prefix,
            // a check whether or not the location of the executable file is inside this
            // build tree is enough to know whether or not it is executed from within the
            // build tree or an installation.
            os::path::realpath("@BUILD_ROOT_PATH_CONFIG@"));
    // return whether executable directory is inside the build tree or not
    return !(rel_path == "" || rel_path == "." ||
            (rel_path.substr(0, 2) == ".." && (rel_path.size() == 2 || rel_path[2] == '/')));
}

// ---------------------------------------------------------------------------
string get_target_uid(const string& name)
{
    const ExecutableTargetInfo& info = ExecutableTargetInfo::instance();
    return info.get_target_uid(name);
}

// ---------------------------------------------------------------------------
bool is_known_target(const string& name)
{
    const ExecutableTargetInfo& info = ExecutableTargetInfo::instance();
    return info.is_known_target(name);
}

// ---------------------------------------------------------------------------
string exepath(const string& name)
{
    // return path of this executable if no name given
    if (name.empty()) return os::exepath();
    // get executable target information instance
    const ExecutableTargetInfo& info = ExecutableTargetInfo::instance();
    // get name of executable and check if target name is known
    string exec_name = info.get_executable_name(name);
    // if target is not known
    if (exec_name.empty()) {
        // return input argument assuming that it is already the path of
        // an executable file
        exec_name = name;
        // try to get absolute path using the which command if path is relative
        // TODO Replace use of external which command by C++ implementation
        //      of which() even though BASIS includes a Python implementation
        //      that can also be used on Windows. Still, a native C++
        //      implementation is desireable.
        if (os::path::isrel(exec_name) && info.is_known_target("sbia.basis.which")) {
            vector<string> which(2);
            which[0] = "sbia.basis.which";
            which[1] = name;
            ostringstream oss;
            // attention: this includes a "recursive" call of this function!
            if (execute_process(which, true, &oss, true) == 0) {
                exec_name = oss.str();
                const string::size_type end = exec_name.find_last_not_of(" \t\n\r");
                if (end == string::npos) {
                    exec_name = "";
                } else {
                    exec_name.erase(end + 1);
                }
            }
        }
        return exec_name;
    }
    // prepend either build tree directory or installation directory
    if (executing_in_build_tree()) {
        return os::path::join(info.get_build_directory(name), exec_name);
    } else {
        return os::path::join(info.get_installation_directory(name), exec_name);
    }
}

// ---------------------------------------------------------------------------
string exename(const std::string& name)
{
    string exec_path = exepath(name);
    if (exec_path.empty()) return "";
#if WINDOWS
    string ext = os::path::fileext(exec_path);
    if (ext == ".exe" || ext == ".com") {
        return os::path::filename(exec_path);
    } else {
        return os::path::basename(exec_path);
    }
#else
    return os::path::basename(exec_path);
#endif
}

// ---------------------------------------------------------------------------
string exedir(const std::string& name)
{
    string exec_path = exepath(name);
    return exec_path.empty() ? "" : os::path::dirname(exec_path);
}

// ===========================================================================
// package directories
// ===========================================================================

// ---------------------------------------------------------------------------
string get_installation_prefix()
{
#ifdef LIBEXEC
    return os::path::join(os::exedir(), "@LIBEXEC_PATH_PREFIX_CONFIG@");
#else
    return os::path::join(os::exedir(), "@RUNTIME_PATH_PREFIX_CONFIG@");
#endif
}

// ---------------------------------------------------------------------------
string bindir()
{
    if (executing_in_build_tree()) {
        return "@RUNTIME_BUILD_PATH_CONFIG@";
    } else {
        return os::path::join(get_installation_prefix(), "@RUNTIME_PATH_CONFIG@");
    }
}

// ---------------------------------------------------------------------------
string libexecdir()
{
    if (executing_in_build_tree()) {
        return "@LIBEXEC_BUILD_PATH_CONFIG@";
    } else {
        return os::path::join(get_installation_prefix(), "@LIBEXEC_PATH_CONFIG@");
    }
}

// ---------------------------------------------------------------------------
string libdir()
{
    if (executing_in_build_tree()) {
        return "@LIBRARY_BUILD_PATH_CONFIG@";
    } else {
        return os::path::join(get_installation_prefix(), "@LIBRARY_PATH_CONFIG@");
    }
}

// ---------------------------------------------------------------------------
string datadir()
{
    if (executing_in_build_tree()) {
        return "@DATA_BUILD_PATH_CONFIG@";
    } else {
        return os::path::join(get_installation_prefix(), "@DATA_PATH_CONFIG@");
    }
}

// ===========================================================================
// command execution
// ===========================================================================

// ---------------------------------------------------------------------------
string to_quoted_string(const vector<string>& args)
{
    return Subprocess::tostring(args);
}

// ---------------------------------------------------------------------------
vector<string> split_quoted_string(const string& args)
{
    return Subprocess::split(args);
}

// ---------------------------------------------------------------------------
int execute_process(const string& cmd, bool quiet, ostream* out,
                    bool allow_fail, int verbose, bool simulate)
{
    vector<string> args = Subprocess::split(cmd);
    return execute_process(args, quiet, out, allow_fail, verbose, simulate);
}

// ---------------------------------------------------------------------------
int execute_process(vector<string>& args, bool quiet, ostream* out,
                    bool allow_fail, int verbose, bool simulate)
{
    if (args.empty() || args[0].empty()) {
        BASIS_THROW(SubprocessError, "execute_process(): No command specified");
    }
    // map build target name to executable file path
    string exec_path = exepath(args[0]);
    // prepend absolute path of found executable
    if (!exec_path.empty()) args[0] = exec_path;
    // some verbose output
    if (verbose > 0) {
        cout << "$ " << Subprocess::tostring(args);
        if (simulate) cout << " (simulated)";
        cout << endl;
    }
    // execute command
    char buf[1024];
    int  n;
    int status = 0;
    Subprocess p;
    if (!p.popen(args, Subprocess::RM_NONE, Subprocess::RM_PIPE, Subprocess::RM_PIPE)) {
        BASIS_THROW(SubprocessError, "execute_process(): Failed to create subprocess");
    }
    // read child's stdout (blocking)
    if (!quiet || out != NULL) {
        while ((n = p.read(buf, 1023)) > 0) {
            buf[n] = '\0';
            if (!quiet) {
                cout << buf;
                cout.flush();
            }
            if (out) *out << buf;
        }
    }
    // wait for child process
    if (!p.wait()) {
        BASIS_THROW(SubprocessError, "execute_process(): Failed to wait for subprocess");
    }
    // write error messages to stderr of parent process
    while ((n = p.read(buf, 1023, true)) > 0) {
        buf[n] = '\0';
        cerr << buf;
    }
    // get exit code
    status = p.returncode();
    // if command failed, throw an exception
    if (status != 0 && !allow_fail) {
        BASIS_THROW(SubprocessError, "Command " << Subprocess::tostring(args) << " failed");
    }
    return status;
}

// ===========================================================================
// class: ExecutableTargetInfo (definition)
// ===========================================================================

// ---------------------------------------------------------------------------
const ExecutableTargetInfo& ExecutableTargetInfo::instance()
{
    static ExecutableTargetInfo instance;
    return instance;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_target_uid(const string& target) const
{
    // empty(, invalid) target name remains unchanged
    if (target.empty()) return "";
    // in case of a leading namespace separator, do not modify target name
    if (target[0] == '.') return target;
    // project namespace
    string prefix = string("@PROJECT_NAMESPACE_CMAKE@");
    // try prepending namespace or parts of it until target is known
    for (;;) {
        if (_exec_names.find(prefix + "." + target) != _exec_names.end()) {
            return prefix + "." + target;
        }
        string::size_type pos = prefix.rfind('.');
        if (pos == string::npos) break;
        prefix = prefix.substr(0, pos);
    }
    // otherwise, return target name unchanged
    return target;
}

// ---------------------------------------------------------------------------
bool ExecutableTargetInfo::is_known_target(const string& target) const
{
    if (target.empty()) return false;
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    return _exec_names.find(uid) != _exec_names.end();
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_executable_name(const string& target) const
{
    if (target.empty()) return "";
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = _exec_names.find(uid);
    if (it == _exec_names.end ()) return "";
    return it->second;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_build_directory(const string& target) const
{
    if (target.empty()) return "";
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = _build_dirs.find(uid);
    if (it == _build_dirs.end()) return "";
#if defined CMAKE_INTDIR
    // this subdirectory is used by CMake generators for IDEs such as Visual Studio
    return os::path::join(it->second, CMAKE_INTDIR);
#else
    return it->second;
#endif
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::get_installation_directory(const string& target) const
{
    if (target.empty()) return "";
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = get_target_uid(target);
    MapIterator it = _install_dirs.find(uid);
    if (it == _install_dirs.end()) return "";
    return os::path::join(get_installation_prefix(), it->second);
}

// ---------------------------------------------------------------------------
ExecutableTargetInfo::ExecutableTargetInfo()
{
    @EXECUTABLE_TARGET_INFO@
}


} // namespace basis

} // namespace @PROJECT_NAME_LOWER@

} // namespace @BASIS_NAMESPACE_LOWER@
