##############################################################################
# @file  stdaux.sh
# @brief Standard auxiliary functions for BASH.
#
# @note The stdaux.sh module is automatically created by BASIS from the
#       template file stdaux.sh.in which is part of the BASIS installation.
#
# Copyright (c) 2011 University of Pennsylvania. All rights reserved.
# See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
#
# Contact: SBIA Group <sbia-software at uphs.upenn.edu>
#
# @ingroup BashUtilities
##############################################################################

# return if already loaded
[ "${_SBIA_@PROJECT_NAME_UPPER@_STDAUX_INCLUDED:-0}" -eq 1 ] && return 0
_SBIA_@PROJECT_NAME_UPPER@_STDAUX_INCLUDED=1


## @addtogroup BashUtilities
#  @{


# ============================================================================
# version / contact
# ============================================================================

##############################################################################
# @brief Print version information.
#
# @param [in] name      Name of program. Give a constant expression here,
#                       @b not the name of the executable as extracted from
#                       the first command-line argument or similar! By default,
#                       however, the executable name is extracted from the first
#                       command-line argument. This is @b not recommended.
# @param [in] copyright Copyright and license notice. Defaults to official
#                       SBIA software license.
#
# @returns Nothing.
function print_version
{
    local name=${1:-${0##*/}}
    local copyright=${2:-}
    if [ -z "${copyright}" ]; then
        copyright="Copyright (c) University of Pennsylvania. All rights reserved.\n\
See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file."
    fi
    echo "${name} (@PROJECT_NAME@) version @PROJECT_VERSION_AND_REVISION@"
    echo -e "${copyright}"
}

##############################################################################
# @brief Print contact information.
#
# @param [in] contact Contact name. Defaults to official software contact.
#                     Generally, it is @b not advised to use a contact different
#                     from the official one.
#
# @returns Nothing.
function print_contact
{
    echo "Contact:"
    if [ $# -gt 0 ]; then
        echo -e "  $1"
    else
        echo "  SBIA Group <sbia-software at uphs.upenn.edu>"
    fi
}

# ============================================================================
# command execution
# ============================================================================

##############################################################################
# @brief Execute command as subprocess.
#
# See basis_array_to_quoted_string() for a function to convert a command-line
# given as array of arguments into a quoted string that can be passed to
# this function.
#
# Note that the output of the command is not redirected by this function.
# In order to execute the command quietly, call this function as:
# @code
# execute_process 'ls /' &> /dev/null
# @endcode
# In order to store the command output in a variable including error messages
# use it as follows:
# @code
# output=`execute_process 'ls /' 2>&1`
# @endcode
# Note that in this case, the option @p allow_fail has no effect as the
# calling shell will never be terminated even if @p allow_fail is non-zero
# and the command failed, thus invoking an exit(). This, however, only
# exits the subshell. Checking the exit code $? is in this case recommended.
#
# @param [in] args       Command-line given as quoted string.
# @param [in] allow_fail If 0, failing of the command does not result in
#                        the current shell being terminated with exit code 1.
# @param [in] verbose    Verbosity of output messages. A value greater than
#                        zero enables verbose output of the command being
#                        executed. This does not affect the verbosity of the
#                        command itself.
# @param [in] simulate   If 0, the command is not actually executed, but
#                        the command-line only printed to stdout.
#
# @returns Exit code of subprocess. The output of the command is not redirected.
#          Hence, in order to store the commands
function execute_process
{
    [ -n "$1" ] || return 1
    local args="$1"
    local allow_fail="${2:-1}"
    local verbose="${3:-0}"
    local simulate="${4:-1}"
    local status=0
    # extract command from command-line
    match "$args" "^[ ]*('([^']|\\\')*[^\\]'|\"([^\"]|\\\\\")*[^\\]\"|[^ ]+)(.*)$"
    [ $? -eq 0 ] || return 1
    local command=${BASH_REMATCH[1]}
    local arguments=${BASH_REMATCH[4]}
    # map build target name to file
    local exec_path && get_executable_path exec_path "${command}"
    if [ -z "${exec_path}" ]; then
        echo "${command}: Either unknown build target or command not found" 1>&2
        exit 1
    fi
    # if path contains a whitespace character...
    if match "${exec_path}" '[ \t\n]'; then
        # ...quote path with quotes inside path escaped
        exec_path=`echo "${exec_path}" | sed 's/"/\\"/g'`
        exec_path="\"${exec_path}\""
    fi
    # prepend absolute path of found executable
    args="${exec_path}${arguments}"
    # some verbose output
    if [ ${verbose} -gt 0 ]; then
        echo "\$ ${args}"
    fi
    # execute command
    [ ${simulate} -eq 0 ] || eval "${args}"
    status=$?
    # if command failed, exit
    [ ${status} -eq 0 -o ${allow_fail} -eq 0 ] || {
        echo "Command ${args} failed" 1>&2
        exit 1
    }
    # return exit code
    return ${status}
}


## @}
# Doxygen group BashUtilities

