##############################################################################
# @file  stdaux.sh
# @brief Standard auxiliary functions for BASH.
#
# @note The stdaux.sh module is automatically created by BASIS from the
#       template file stdaux.sh.in which is part of the BASIS installation.
#
# Copyright (c) 2011 University of Pennsylvania. All rights reserved.
# See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
#
# Contact: SBIA Group <sbia-software at uphs.upenn.edu>
#
# @ingroup BashUtilities
##############################################################################

# return if already loaded
[ "${_SBIA_@PROJECT_NAME_UPPER@_STDAUX_INCLUDED:-0}" -eq 1 ] && return 0
_SBIA_@PROJECT_NAME_UPPER@_STDAUX_INCLUDED=1


## @addtogroup BashUtilities
#  @{


# ============================================================================
# version / contact
# ============================================================================

##############################################################################
# @brief Print version information.
#
# @param [in] name      Name of program. Give a constant expression here,
#                       @b not the name of the executable as extracted from
#                       the first command-line argument or similar! By default,
#                       however, the executable name is extracted from the first
#                       command-line argument. This is @b not recommended.
# @param [in] copyright Copyright and license notice. Defaults to official
#                       SBIA software license.
#
# @returns Nothing.
function print_version
{
    local name=${1:-${0##*/}}
    local copyright=${2:-}
    if [ -z "${copyright}" ]; then
        copyright="Copyright (c) University of Pennsylvania. All rights reserved.\n\
See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file."
    fi
    echo "${name} (@PROJECT_NAME@) version @PROJECT_VERSION_AND_REVISION@"
    echo -e "${copyright}"
}

##############################################################################
# @brief Print contact information.
#
# @param [in] contact Contact name. Defaults to official software contact.
#                     Generally, it is @b not advised to use a contact different
#                     from the official one.
#
# @returns Nothing.
function print_contact
{
    echo "Contact:"
    if [ $# -gt 0 ]; then
        echo -e "  $1"
    else
        echo "  SBIA Group <sbia-software at uphs.upenn.edu>"
    fi
}

# ============================================================================
# process execution
# ============================================================================

##############################################################################
# @brief Execute command as subprocess.
#
# @todo Instead of first splitting a command-line string into an array and
#       then creating a command-line string again, just extract the first
#       argument, map it to the executable file path, and then prepend it
#       to the remaining part of the original command-line.
function execute_process
{
    [ -n "$1" ] || return 1
    local args="$1"
    local allow_fail="${2:-1}"
    local verbose="${3:-0}"
    local simulate="${4:-1}"
    local i=0
    local status=0
    local arg=''
    local cmd=''
    # convert args to array of strings
    if [ ${#args[@]} -eq 1 ]; then
        # match arguments from left to right
        while match "$args" "[ ]*('([^']|\\\')*'|\"([^\"]|\\\\\")*\"|[^ ]*)(.*)"; do
            # matched argument including quotes
            arg="${BASH_REMATCH[1]}"
            # remove quotes
            arg=`echo "${arg}" | sed "s/^['\"]//;s/['\"]$//"`
            # replace quoted quotes within argument by quotes
            arg=`echo "${arg}" | sed "s/[\\]\'/\'/g;s/[\\]\"/\"/g"`
            # add to argument vector
            argv[${#argv[@]}]="${arg}"
            # continue with residual command-line
            args="${BASH_REMATCH[4]}"
        done
        args=("${argv[@]}")
        unset argv
    fi
    # map build target name to executable file path
    local path && get_executable_path path "${args[0]}"
    [ -n "${path}" ] && args[0]="${path}"
    # create command-line string
    i=0
    while [ $i -lt ${#args[@]} ]; do
        arg=`echo "${args[$i]}" | sed "s/\'/\\\'/g;s/\"/\\\\\\\"/g"`
        cmd="${cmd} \"${arg}\""
        (( i++ ))
    done
    # some verbose output
    if [ ${verbose} -gt 0 -o ${simulate} -eq 0 ]; then
        i=0
        echo -n "> ${cmd}"
        [ ${simulate} -eq 0 ] && echo -n " (simulated)"
        echo
    fi
    # execute command
    [ ${simulate} -ne 0 ] && eval "${evalstr}"
    status=$?
    # if command failed, exit
    [ ${status} -eq 0 ] || {
        echo "Subprocess ${evalstr} failed" 1>&2
        exit 1
    }
    # return
    return ${status}
}


## @}
# Doxygen group BashUtilities

