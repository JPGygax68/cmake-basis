##############################################################################
# @file  executabletargetinfo.sh
# @brief Provides information about the executables built by BASIS.
#
# @note The executabletargetinfo.sh module is automatically created by
#       BASIS from the template file executabletargetinfo.sh.in which is
#       part of the BASIS installation.
#
# Copyright (c) 2011 University of Pennsylvania. All rights reserved.<br />
# See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
#
# Contact: SBIA Group <sbia-software at uphs.upenn.edu>
##############################################################################

# return if already loaded
[ "${_SBIA_BASIS_EXECUTABLETARGETINFO_INCLUDED:-0}" -eq 1 ] && return 0
_SBIA_BASIS_EXECUTABLETARGETINFO_INCLUDED=1


# ============================================================================
# constants
# ============================================================================

## @brief Absolute directory path of executabletargetinfo.sh module.
readonly _EXECUTABLETARGETINFO_DIR=@BASIS_BASH___DIR__@

# ============================================================================
# modules
# ============================================================================

source "${_EXECUTABLETARGETINFO_DIR}/@_BASIS_LIBRARY_DIR@/core.sh"
source "${_EXECUTABLETARGETINFO_DIR}/@_BASIS_LIBRARY_DIR@/path.sh"

# ============================================================================
# public functions
# ============================================================================

## @addtogroup BasisBashUtilities
#  @{


# ----------------------------------------------------------------------------
## @brief Get UID of build target.
#
# @param [out] uid    UID of build target.
# @param [in]  target Name/UID of build target.
#
# @returns Nothing.
#
# @retval 0 On success.
# @retval 1 On failure.
function get_target_uid
{
    [ -n "$1" ] && [ $# -eq 2 ] || return 1
    local target="$2"
    # initialize module if not done yet - this is only done here because
    # whenever information is looked up about an executable target, this
    # function is invoked first
    if [ -z "${_EXECUTABLETARGETINFO_INITIALIZED}" ]; then
        _executabletargetinfo_initialize || return 1
    fi
    # empty string as input remains unchanged
    [ -z "${target}" ] && local "$1" && upvar $1 '' && return 0
    # in case of a leading namespace separator, do not modify target name
    [ "${target:0:1}" == '.' ] && local "$1" && upvar $1 "${target}" && return 0
    # project namespace
    local prefix="@PROJECT_NAMESPACE_CMAKE@.DUMMY"
    # try prepending namespace or parts of it until target is known
    local path=''
    while [ "${prefix/\.*/}" != "${prefix}" ]; do
        prefix="${prefix%\.*}"
        _executabletargetinfo_get path "${prefix}.${target}" LOCATION
        if [ -n "${path}" ]; then
            local "$1" && upvar $1 "${prefix}.${target}"
            return 0
        fi
    done
    # otherwise, return target name unchanged
    local "$1" && upvar $1 "${target}"
}

# ----------------------------------------------------------------------------
## @brief Determine whether a given target is known.
#
# @param [in] target Name/UID of build target.
#
# @returns Whether the given build target is known by this module.
function is_known_target
{
    get_target_uid uid "$1"
    [ -n "${uid}" ] || return 1
    local path && _executabletargetinfo_get path "${uid}" LOCATION
    [ -n "${path}" ]
}

# ----------------------------------------------------------------------------
## @brief Get name of executable file.
#
# @param [out] name   Name of the executable or an empty string if unknown.
# @param [in]  target Name/UID of build target. If no argument is given,
#                     the name of the calling executable is returned instead.
#
# @returns Nothing.
#
# @retval 0 On success.
# @retval 1 On failure.
function get_executable_name
{
    [ -n "$1" ] && [ $# -eq 1 -o $# -eq 2 ] || return 1

    local name

    # if no target name given, get name of this executable
    if [ $# -lt 2 ]; then
        name="${0##*/}"
    # otherwise, get name of executable built by named target
    else
        local path && get_executable_path path "$2"
        [ $? -eq 0 ] || return 1
        name="`basename "${path}"`"
        [ $? -eq 0 ] || return 1
    fi

    local "$1" && upvar $1 "${name}"
}

# ----------------------------------------------------------------------------
## @brief Get directory of executable file.
#
# @param [out] dir    Absolute directory of executable file.
# @param [in]  target Name/UID of build target. If no argument is given,
#                     the directory where the file of the calling executable
#                     is located is returned.
#
# @returns Nothing.
#
# @retval 0 On success.
# @retval 1 On failure.
function get_executable_directory
{
    [ -n "$1" ] && [ $# -eq 1 -o $# -eq 2 ] || return 1

    local path

    # if no target name given, get path of this executable
    if [ $# -lt 2 ]; then
        get_executable_path path
    # otherwise, get path of executable of named target
    else
        get_executable_path path "$2"
    fi
    [ $? -eq 0 ] || return 1
    # get directory component of path
    local dir="`dirname "${path}"`"

    local "$1" && upvar $1 "${dir}"
}

# ----------------------------------------------------------------------------
## @brief Get absolute path of executable file.
#
# This function determines the absolute file path of an executable. If no
# arguments are given, the absolute path of this executable is returned.
# If the given argument is a known build target name, the absolute path
# of the executable built by this target is returned. Otherwise, the named
# command is searched in the system PATH and it's absolute path returned
# if found. If the given argument is neither the name of a known build target
# nor an executable found on the PATH, an empty string is returned and
# the return value is 1.
#
# @param [out] path   Absolute path of executable file.
# @param [in]  target Name/UID of build target. If no argument is given,
#                     the file path of the calling executable is returned.
#
# @returns Nothing.
#
# @retval 0 On success.
# @retval 1 On failure.
function get_executable_path
{
    [ -n "$1" ] && [ $# -eq 1 -o $# -eq 2 ] || return 1

    local path

    # if no target name given, get path of this executable
    if [ $# -lt 2 ]; then
        path="`get_real_path "$0"`"
    # otherwise, get path of executable built by named target
    else
        # get UID of target
        local uid && get_target_uid uid "$2"
        [ "${uid:0:1}" == '.' ] && uid=${uid:1}
        if [ -n "${uid}" ]; then
            # get path relative to this module
            _executabletargetinfo_get path "${uid}" LOCATION
            if [ -n "${path}" ]; then
                # make path absolute
                path=`to_absolute_path "${_EXECUTABLETARGETINFO_DIR}" "${path}"`
                [ $? -eq 0 ] || return 1
            else
                path=`/usr/bin/which "$2" 2> /dev/null`
            fi
        else
            path=`/usr/bin/which "$2" 2> /dev/null`
        fi
    fi

    local "$1" && upvar $1 "${path}"
    [ $? -eq 0 ] && [ -n "${path}" ]
}


## @}
# end of Doxygen group

# ============================================================================
# private helpers
# ============================================================================

# ----------------------------------------------------------------------------
## @brief Sanitize string for use in variable name.
#
# @param [out] out Sanitized string.
# @param [in]  str String to be sanitized.
#
# @returns Nothing.
#
# @retval 0 On success.
# @retval 1 On failure.
function _executabletargetinfo_sanitize
{
    [ $# -eq 2 ] || return 1
    [ -n "$2" ] || {
        upvar $1 ''
        return 0
    }
    local sane="`echo -n "$2" | tr [:space:] '_' | tr -c [:alnum:] '_'`"
    [ -n "${sane}" ] || {
        echo "_executabletargetinfo_sanitize(): Failed to sanitize string '$2'" 1>&2
        exit 1
    }
    local "$1" && upvar $1 "${sane}"
}

# ----------------------------------------------------------------------------
## @brief Add (key, value) pair to executable target info "hash".
#
# @sa _executabletargetinfo_get()
#
# @param [in] key   Hash key.
# @param [in] name  Name of the hash table.
# @param [in] value Value associated with the given hash key.
#
# @returns Sets a readonly variable that represents the (key, value) entry.
function _executabletargetinfo_add
{
    [ $# -eq 3 ] || return 1

    local key  && _executabletargetinfo_sanitize key  "$1"
    local name && _executabletargetinfo_sanitize name "$2"
    [ -n "${key}" ] && [ -n "${name}" ] || {
        if [ -z "${key}" ] && [ -z "${name}" ]; then
            echo "_executabletargetinfo_add(): Neither lookup table nor key specified" 1>&2
        elif [ -z "${key}" ]; then
            echo "_executabletargetinfo_add(): No key specified for addition to hash table '${name}'" 1>&2
        else
            echo "_executabletargetinfo_add(): No lookup table given for addition of key '${key}'" 1>&2
        fi
        exit 1
    }
    eval "readonly __EXECUTABLETARGETINFO_${name}_${key}='$3'"
    if [ $? -ne 0 ]; then
        echo "Failed to add ${name} of key ${key} to executable target info map!" 1>&2
        echo "This may be caused by two CMake build target names being converted to the same key." 1>&2
        exit 1
    fi
}

# ----------------------------------------------------------------------------
## @brief Get value from executable target info "hash".
#
# @sa _executabletargetinfo_add()
#
# @param [out] value Value corresponding to given @p key
#                    or an empty string if key is unknown.
# @param [in]  key   Hash key.
# @param [in]  name  Name of the hash table.
#
# @returns Nothing.
#
# @retval 0 On success.
# @retval 1 On failure.
function _executabletargetinfo_get
{
    [ $# -eq 3 ] || return 1

    local key  && _executabletargetinfo_sanitize key  "$2"
    local name && _executabletargetinfo_sanitize name "$3"
    [ -n "${key}" ] && [ -n "${name}" ] || {
        if [ -z "${key}" ] && [ -z "${name}" ]; then
            echo "_executabletargetinfo_get(): Neither lookup table nor key specified" 1>&2
        elif [ -z "${key}" ]; then
            echo "_executabletargetinfo_get(): No key specified for lookup in hash table '${name}'" 1>&2
        else
            echo "_executabletargetinfo_get(): No lookup table given for lookup of key '${key}'" 1>&2
        fi
        exit 1
    }
    eval "local value=\${__EXECUTABLETARGETINFO_${name}_${key}}"

    local "$1" && upvar $1 "${value}"
}

# ----------------------------------------------------------------------------
## @brief Initialize executable target information.
#
# This function initializes the structures of information about the executable
# build targets. If this function is executed another time, it does nothing
# because the structures are initialized already. In order to reduce the start
# time of applications that do not make use of this module, the initialization
# is only performed on demand.
#
# The initialization is done in get_target_uid() as this function is always
# called first before any lookup of information.
#
# @returns Nothing.
#
# @retval 0 On success.
# @retval 1 On failure.
function _executabletargetinfo_initialize
{
    [ $# -eq 0 ] || return 1

    @EXECUTABLE_TARGET_INFO@

    _EXECUTABLETARGETINFO_INITIALIZED=1
    return 0
}

# ============================================================================
# aliases (optional)
# ============================================================================

if [ -z "${use_executable_target_aliases}" ] || [ ${use_executable_target_aliases} -eq 0 ]; then
    return
fi

# define aliases of build target names to executable file paths
@EXECUTABLE_ALIASES@

# enable expansion of aliases also in non-interactive shells
shopt -s expand_aliases
