/*!
 * \file  config.h
 * \brief Default include file with project configuration.
 *
 * \note The config.h file is automatically generated by BASIS from the
 *       file config.h.in which is part of BASIS.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See COPYING file or https://www.rad.upenn.edu/sbia/software/license.html.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 */

#pragma once
#ifndef SBIA_@PROJECT_NAME_UPPER@_CONFIG_H_
#define SBIA_@PROJECT_NAME_UPPER@_CONFIG_H_


#include <string>


//////////////////////////////////////////////////////////////////////////////
// system
//////////////////////////////////////////////////////////////////////////////

/*!
 * \def   LINUX
 * \brief Whether the sources are compiled on a Linux system.
 */
#ifndef LINUX
#  define LINUX (defined (linux) || defined (__linux))
#endif

/*!
 * \def   WINDOWS
 * \brief Whether the sources are compiled on a Windows system.
 */
#ifndef WINDOWS
#  define WINDOWS (defined (_WIN32) || defined (WIN32) || defined (_WINDOWS))
#endif

/*!
 * \def   MACOS
 * \brief Whether the sources are compiled on a Mac OS system.
 */
#ifndef MACOS
#  define MACOS (defined (__APPLE__) || defined (__OSX__))
#endif

/*!
 * \def   UNIX
 * \brief Whether the sources are compiled on a Unix-based system.
 */
#ifndef UNIX
#  define UNIX (!WINDOWS)
#endif

/*!
 * \def   HAVE_LONG_LONG
 * \brief Whether the long long type is supported by the compiler.
 */
#ifdef HAVE_LONG_LONG
#  if HAVE_LONG_LONG != @HAVE_LONG_LONG@
#    error "Macro HAVE_LONG_LONG was previously defined with different value!"
#  endif
#else
#  define HAVE_LONG_LONG @HAVE_LONG_LONG@
#endif

/*!
 * \def HAVE_SSTREAM
 * \brief Whether the ANSI string stream classes are available.
 */
#ifdef HAVE_SSTREAM
#  if HAVE_SSTREAM != @HAVE_SSTREAM@
#    error "Macro HAVE_SSTREAM was previously defined with different value!"
#  endif
#else
#  define HAVE_SSTREAM @HAVE_SSTREAM@
#endif

/*!
 * \def   HAVE_STRSTREAM
 * \brief Whether the obsolete string stream classes are available.
 *
 * \note As the strstream implementations are obsolete already for a long
 *       time, this macro always evaluates to 0.
 */
#ifdef HAVE_STRSTREAM
#  undef HAVE_STRSTREAM
#endif
#define HAVE_STRSTREAM 0

/*!
 * \def HAVE_PTHREAD
 * \brief Whether the pthread library is available.
 */
#ifdef HAVE_PTHREAD
#  if HAVE_PTHREAD != @HAVE_PTHREAD@
#    error "Macro HAVE_PTHREAD was previously defined with different value!"
#  endif
#else
#  define HAVE_PTHREAD @HAVE_PTHREAD@
#endif

/*!
 * \def HAVE_TR1_TUPLE
 * \brief Whether the tr1/tuple header file is available.
 *
 * \note This header file is only more recently supported by compilers
 *       and be used by Google Test, for example. If not supported by
 *       the compiler, Google Test can use it's own implementation.
 */
#ifdef HAVE_TR1_TUPLE
#  if HAVE_TR1_TUPLE != @HAVE_TR1_TUPLE@
#    error "Macro HAVE_TR1_TUPLE was previously defined with different value!"
#  endif
#else
#  define HAVE_TR1_TUPLE @HAVE_TR1_TUPLE@
#endif

//////////////////////////////////////////////////////////////////////////////
// namespace
//////////////////////////////////////////////////////////////////////////////

/*!
 * \brief Full project own namespace identifier.
 *
 * This macro should preferably be used when referring to the project own
 * namespace. The namespace can then be renamed later on without affecting
 * written source code.
 *
 * \note Namespace identifier may reflect a nested namespace.
 */
#define SBIA_@PROJECT_NAME_UPPER@_NAMESPACE \
    ::sbia::@PROJECT_NAME_LOWER@

/*!
 * \brief Macro used to enter project own namespace.
 *
 * Example: 
 * \code
 * SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN
 *
 * // project source code within project own namespace
 *
 * SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
 * \endcode 
 */ 
#define SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN \
    namespace sbia { namespace @PROJECT_NAME_LOWER@ {

/*!
 * \brief Macro used to exit project own namespace.
 *
 * Example: 
 * \code
 * SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN
 *
 * // project source code within project own namespace
 *
 * SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END
 * \endcode 
 */
#define SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END } }

//////////////////////////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////////////////////////

SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN


// ---------------------------------------------------------------------------
// project attributes
// ---------------------------------------------------------------------------

/*!
 * \brief The project name.
 */
extern const std::string cProjectName;

/*!
 * \brief The major version number.
 */ 
extern const unsigned int cVersionMajor;

/*!
 * \brief The minor version number.
 */
extern const unsigned int cVersionMinor;

/*!
 * \brief The patch number.
 */
extern const unsigned int cVersionPatch;

/*!
 * \brief The version string given as "<major>.<minor>.<patch>".
 */
extern const std::string cVersion;

/*!
 * \brief The SVN revision number of the project (if applicable).
 *
 * The SVN revision number can only be provided when the project is build from
 * a revision controlled working copy of the project. It is not available in
 * case of a source distribution package of the project. Hence, it may only be
 * used for informational debug outputs, but not for actual version dependent
 * processing. If the revision number is not known, this constant is set to 0.
 *
 * Example:
 * \code
 * if (cRevision) {
 *     std::cout << "Revision: " << cRevision << std::endl;
 * } else {
 *     std::cout << "Revision: n/a" << std::endl;
 * }
 * \endcode
 */
extern const unsigned int cRevision;

// ---------------------------------------------------------------------------
// paths
// ---------------------------------------------------------------------------

/*!
 * \brief Path prefix used by runtime executables.
 *
 * This path prefix is used by runtime executables as prefix for any of the
 * relative path constants defined globally.
 *
 * Example:
 * <code>
 * std::string path = GetExecutablePath () + cRuntimePathPrefix + cDataPath;
 * <endcode>
 *
 * The resulting path is the absolute path to the shared data directory if
 * executed by a main executable which is located in the runtime directory.
 */
extern const std::string cRuntimePathPrefix;

/*!
 * \brief Path prefix used by auxiliary executables.
 *
 * This path prefix is used by auxiliary executables as prefix for any of the
 * relative path constants defined globally.
 *
 * Example:
 * <code>
 * std::string path = GetExecutablePath () + cLibexecPathPrefix + cDataPath;
 * <endcode>
 *
 * The resulting path is the absolute path to the shared data directory if
 * executed by an auxiliary executable which is located in the libexec directory.
 */
extern const std::string cLibexecPathPrefix;

/*!
 * \brief Path to runtime executables relative to executable path prefix.
 */
extern const std::string cRuntimePath;

/*!
 * \brief Path to auxiliary executables relative to executable path prefix.
 */
extern const std::string cLibexecPath;

/*!
 * \brief Path to shared data relative to executable path prefix.
 */
extern const std::string cDataPath;


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END


#endif // SBIA_@PROJECT_NAME_UPPER@_CONFIG_H_

