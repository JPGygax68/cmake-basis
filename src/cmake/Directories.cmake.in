##############################################################################
# @file  @PROJECT_NAME@Directories.cmake
# @brief CMAke variables of project directories.
#
# @note The file @PROJECT_NAME@Directories.cmake is automatically generated by
#       BASIS from the template file Directories.cmake.in which is part of the
#       BASIS installation.
#
# The project template must follow the directory structure as defined by the
# <tt>PROJECT_*_DIR</tt> variables. Ideally, when changing the name of one of
# these directories, only the directory structure of the template needs to be
# updated. The BASIS CMake functions should not be required to change as they
# are supposed to use these variables instead of the actual names.
#
# If this project is a module and modules shall reside in the same namespace
# as the top-level project (if option @c BASIS_USE_MODULE_NAMESPACES is @c OFF),
# the directories are the same for all modules except of the
# <tt>PROJECT_*_DIR</tt> variables, which refer to the source tree of the
# active module. Otherwise, the modules add their name to the paths such that
# the files of the modules are separated by subdirectories.
#
# Copyright (c) 2011 University of Pennsylvania. All rights reserved.
# See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
#
# Contact: SBIA Group <sbia-software at uphs.upenn.edu>
#
# @ingroup CMakeAPI
##############################################################################

## @addtogroup CMakeAPI
#  @{


# ============================================================================
# source tree
# ============================================================================

## @brief Absolute path of directory of project sources in source tree.
set (PROJECT_CODE_DIR "@PROJECT_SOURCE_DIR@/src")
## @brief Absolute path of directory of BASIS project configuration in source tree.
set (PROJECT_CONFIG_DIR "@PROJECT_SOURCE_DIR@/config")
## @brief Absolute path of directory of auxiliary data in source tree.
set (PROJECT_DATA_DIR "@PROJECT_SOURCE_DIR@/data")
## @brief Absolute path of directory of documentation files in source tree.
set (PROJECT_DOC_DIR "@PROJECT_SOURCE_DIR@/doc")
## @brief Absolute path of directory of example in source tree.
set (PROJECT_EXAMPLE_DIR "@PROJECT_SOURCE_DIR@/example")
## @brief Absolute path of diretory of public header files in source tree.
set (PROJECT_INCLUDE_DIR "@PROJECT_SOURCE_DIR@/include")
## @brief Absolute path of directory of project modules.
set (PROJECT_MODULES_DIR "@PROJECT_SOURCE_DIR@/modules")
## @brief Absolute path of directory of testing tree in source tree.
set (PROJECT_TESTING_DIR "@PROJECT_SOURCE_DIR@/test")

# ============================================================================
# testing tree
# ============================================================================

## @brief Absolute path of output directory for tests.
basis_set_if_empty (TESTING_OUTPUT_DIR "@PROJECT_BINARY_DIR@/Testing/Temporary")
## @brief Absolute path of output directory for built test executables.
basis_set_if_empty (TESTING_RUNTIME_DIR "@PROJECT_BINARY_DIR@/Testing/bin")
## @brief Absolute path of output directory for testing libraries.
basis_set_if_empty (TESTING_LIBRARY_DIR "@PROJECT_BINARY_DIR@/Testing/lib")
## @brief Absolute path of output directory for Python modules used for testing.
basis_set_if_empty (TESTING_PYTHON_LIBRARY_DIR "@PROJECT_BINARY_DIR@/Testing/lib/python")
## @brief Absolute path of output directory for Perl modules used for testing.
basis_set_if_empty (TESTING_PERL_LIBRARY_DIR "@PROJECT_BINARY_DIR@/Testing/lib/perl5")

if (PROJECT_IS_MODULE AND BASIS_USE_MODULE_NAMESPACES)
  # Note that Python and Perl modules use their own internal package
  # hierarchy. The top-level directory which is added to the search path
  # for such modules does not have to be changed here.
  foreach (D IN ITEMS OUTPUT RUNTIME LIBRARY)
    set (TESTING_${D}_DIR "${TESTING_${D}_DIR}/@PROJECT_NAME_INFIX@")
  endforeach ()
endif ()

# ============================================================================
# build tree
# ============================================================================

# set directories corresponding to the source tree directories
foreach (P CODE CONFIG DATA DOC EXAMPLE MODULES TESTING)
  basis_get_relative_path (D "${PROJECT_SOURCE_DIR}" "${PROJECT_${P}_DIR}")
  set (BINARY_${P}_DIR "${PROJECT_BINARY_DIR}/${D}")
endforeach ()

# Directory for configured public header files is the same for the top-level
# project and its modules. The proper subdirectories are created by the
# function basis_configure_public_headers().
if (NOT PROJECT_IS_MODULE)
  basis_get_relative_path (D "${PROJECT_SOURCE_DIR}" "${PROJECT_INCLUDE_DIR}")
  set (BINARY_INCLUDE_DIR "${PROJECT_BINARY_DIR}/${D}")
endif ()

## @brief Absolute path of output directory for main executables.
basis_set_if_empty (BINARY_RUNTIME_DIR "@PROJECT_BINARY_DIR@/bin")
## @brief Absolute path of output directory for auxiliary executables.
basis_set_if_empty (BINARY_LIBEXEC_DIR "@PROJECT_BINARY_DIR@/lib")
## @brief Absolute path of output directory for shared libraries and modules.
basis_set_if_empty (BINARY_LIBRARY_DIR "@PROJECT_BINARY_DIR@/lib")
## @brief Absolute path of output directory for static and import libraries.
basis_set_if_empty (BINARY_ARCHIVE_DIR "@PROJECT_BINARY_DIR@/lib")
## @brief Absolute path of output directory for Python modules.
basis_set_if_empty (BINARY_PYTHON_LIBRARY_DIR "@PROJECT_BINARY_DIR@/lib/python")
## @brief Absolute path of output directory for Perl modules.
basis_set_if_empty (BINARY_PERL_LIBRARY_DIR "@PROJECT_BINARY_DIR@/lib/perl5")

if (PROJECT_IS_MODULE AND BASIS_USE_MODULE_NAMESPACES)
  # Note that Python and Perl modules use their own internal package
  # hierarchy. The top-level directory which is added to the search path
  # for such modules does not have to be changed here.
  foreach (D IN ITEMS RUNTIME LIBEXEC LIBRARY ARCHIVE)
    set (BINARY_${D}_DIR "${BINARY_${D}_DIR}/@PROJECT_NAME_INFIX@")
  endforeach ()
endif ()

# set default CMake variable which are, however, not used by BASIS
set (CMAKE_RUNTIME_OUTPUT_DIRECTORY "${BINARY_RUNTIME_DIR}")
set (CMAKE_LIBRARY_OUTPUT_DIRECTORY "${BINARY_LIBRARY_DIR}")
set (CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${BINARY_ARCHIVE_DIR}")

# ============================================================================
# install tree
# ============================================================================

# Attention: In order for CPack to work correctly, the destination paths have
#            to be given relative to CMAKE_INSTALL_PREFIX. Therefore, this
#            prefix must be excluded from the following paths!

# ----------------------------------------------------------------------------
# prefix

# C:/Program Files/Project -> C:/Program Files/SBIA
string (
  REGEX REPLACE
    "/Project$"
    "/${BASIS_NAMESPACE}"
  CMAKE_INSTALL_PREFIX
    "${CMAKE_INSTALL_PREFIX}"
)

## @brief Installation prefix.
set (
  INSTALL_PREFIX
    "${CMAKE_INSTALL_PREFIX}"
  CACHE PATH
    "Prefix used for installation paths."
)

set (CMAKE_INSTALL_PREFIX "${INSTALL_PREFIX}" CACHE INTERNAL "" FORCE)

# ----------------------------------------------------------------------------
# infix

## @brief Whether to use installation sinfix.
option (INSTALL_SINFIX "Whether to use the package-specific installation path suffix/infix." ON)

## @brief Installation sinfix.
if (UNIX)
  set (
    BASIS_INSTALL_SINFIX
      "sbia/@PROJECT_NAME_INFIX@"
    CACHE STRING
      "Suffix/Infix used for installation paths."
  )
else ()
  set (
    BASIS_INSTALL_SINFIX
      "@PROJECT_NAME_INFIX@"
    CACHE STRING
      "Suffix/Infix used for installation paths."
  )
endif ()
mark_as_advanced (BASIS_INSTALL_SINFIX)

if (INSTALL_SINFIX)
  set_property (CACHE BASIS_INSTALL_SINFIX PROPERTY TYPE STRING)
else ()
  set_property (CACHE BASIS_INSTALL_SINFIX PROPERTY TYPE INTERNAL)
endif ()

# ----------------------------------------------------------------------------
# package configuration

# Note: CMake's find_package() command considers certain directories.
#       Hence, the variable BASIS_INSTALL_SINFIX which may not comply to
#       the naming of standard locations considered by this command cannot
#       be used here, but a name depending on this package's name must be used.

## @brief Path of installation directory for CMake package configuration
#         files relative to @c INSTALL_PREFIX.
#
# Install configuration files of modules in subdirectories such that
# CMake does not find them by default. Their might be a case that
# someone is using two projects where the one project is named just
# the same as the module of the other project. The configuration file
# of the module is anyway supposed to be included by the package
# configuration file if this module is requested by the COMPONENTS
# argument to the find_package() command.
if (NOT PROJECT_IS_MODULE)
  if (UNIX)
    set (INSTALL_CONFIG_DIR "lib/cmake/@PROJECT_NAME_INFIX@")
  else ()
    set (INSTALL_CONFIG_DIR "cmake")
  endif ()
else ()
  set (INSTALL_CONFIG_DIR "${INSTALL_CONFIG_DIR}/@PROJECT_NAME_INFIX@")
endif ()

# ----------------------------------------------------------------------------
# executables

## @brief Path of installation directory for runtime executables and shared
#         libraries on Windows relative to @c INSTALL_PREFIX.
set (INSTALL_RUNTIME_DIR "bin")

## @brief Path of installation directory for auxiliary executables
#         relative to @c INSTALL_PREFIX.
if (WIN32)
  set (INSTALL_LIBEXEC_DIR "bin")
else ()
  set (INSTALL_LIBEXEC_DIR "lib")
endif ()

# prepend installation sinfix
if (INSTALL_SINFIX)
  foreach (P RUNTIME LIBEXEC)
    set (VAR "INSTALL_${P}_DIR")
    set (${VAR} "${${VAR}}/${BASIS_INSTALL_SINFIX}")
  endforeach ()
endif ()

# prepend module name
if (PROJECT_IS_MODULE AND BASIS_USE_MODULE_NAMESPACES)
  foreach (P RUNTIME LIBEXEC)
    set (VAR "INSTALL_${P}_DIR")
    set (${VAR} "${${VAR}}/@PROJECT_NAME_INFIX@")
  endforeach ()
endif ()

# ----------------------------------------------------------------------------
# libraries

## @brief Path of installation directory for public header files
#         relative to @c INSTALL_PREFIX.
#
# @note If the @c INCLUDE_PREFIX specifies subdirectories, these will be
#       created underneath this directory during the installation.
set (INSTALL_INCLUDE_DIR "include")

## @brief Path of installation directory for shared libraries on Unix-based
#         systems and module libraries relative to @c INSTALL_PREFIX.
set (INSTALL_LIBRARY_DIR "lib")

## @brief Path of installation directory for static and import libraries
#         relative to @c INSTALL_PREFIX.
set (INSTALL_ARCHIVE_DIR "lib")

# prepend installation sinfix
if (INSTALL_SINFIX)
  foreach (P LIBRARY ARCHIVE)
    set (VAR "INSTALL_${P}_DIR")
    set (${VAR} "${${VAR}}/${BASIS_INSTALL_SINFIX}")
  endforeach ()
endif ()

# prepend module name
if (PROJECT_IS_MODULE AND BASIS_USE_MODULE_NAMESPACES)
  # Note that the INSTALL_INCLUDE_DIR is the same for top-level project
  # and modules. The subdirectory structure within this directory is
  # created by the function basis_configure_public_headers().
  foreach (P LIBRARY ARCHIVE)
    set (VAR "INSTALL_${P}_DIR")
    set (${VAR} "${${VAR}}/@PROJECT_NAME_INFIX@")
  endforeach ()
endif ()

# ----------------------------------------------------------------------------
# script modules

# Similar to the public header files of C/C++ libraries, the modules written
# in Python or Perl are installed with fixed relative directories which
# correspond to the packages these modules belong to:
#
# Python: sbia.<project>
# Perl:   SBIA::<Project>
#
# As here the project name is already part of the file path and has to
# remain fixed, otherwise the modules would not know how to refer to each
# other in the source code, the variable BASIS_INSTALL_SINFIX as well as
# BASIS_USE_MODULE_NAMESPACES are not considered here. Instead, the
# functions basis_add_script() and basis_add_script_finalize() make sure
# that the modules are installed as part of the right packages.

## @brief Path of installation directory for Python modules relative to @c INSTALL_PREFIX.
set (INSTALL_PYTHON_LIBRARY_DIR "lib/python")

## @brief Path of installation directory for Perl modules relative to @c INSTALL_PREFIX.
set (INSTALL_PERL_LIBRARY_DIR "lib/perl5")

# ----------------------------------------------------------------------------
# shared data

## @brief Path of installation directory for shared files
#         relative to @c INSTALL_PREFIX.
set (INSTALL_SHARE_DIR "share")

# prepend installation sinfix
if (INSTALL_SINFIX)
  set (INSTALL_SHARE_DIR "${INSTALL_SHARE_DIR}/${BASIS_INSTALL_SINFIX}")
endif ()

## @brief Path of installation directory for shared data files
#         relative to @c INSTALL_PREFIX.
set (INSTALL_DATA_DIR "${INSTALL_SHARE_DIR}/data")

# prepend module name (regardless of BASIS_USE_MODULE_NAMESPACES)
if (PROJECT_IS_MODULE)
  set (INSTALL_DATA_DIR "${INSTALL_DATA_DIR}/@PROJECT_NAME_INFIX@")
endif ()

# ----------------------------------------------------------------------------
# documentation

## @brief Path of installation directory for documentation files
#         relative to @c INSTALL_PREFIX.
if (UNIX)
  set (INSTALL_DOC_DIR "${INSTALL_SHARE_DIR}/doc")
else ()
  set (INSTALL_DOC_DIR "doc")
endif ()

## @brief Path of installation directory for example files
#         relative to @c INSTALL_PREFIX.
if (UNIX)
  set (INSTALL_EXAMPLE_DIR "${INSTALL_SHARE_DIR}/example")
else ()
  set (INSTALL_EXAMPLE_DIR "example")
endif ()

## @brief Path of installation directory for man pages
#         relative to @c INSTALL_PREFIX.
if (UNIX)
  set (INSTALL_MAN_DIR "${INSTALL_SHARE_DIR}/man")
else ()
  set (INSTALL_MAN_DIR "man")
endif ()

# prepend installation sinfix
if (WIN32 AND INSTALL_SINFIX)
  foreach (P DOC EXAMPLE MAN)
    set (VAR "INSTALL_${P}_DIR")
    set (${VAR} "${${VAR}}/${BASIS_INSTALL_SINFIX}")
  endforeach ()
endif ()

# prepend module name (regardless of BASIS_USE_MODULE_NAMESPACES)
if (PROJECT_IS_MODULE)
  foreach (P DOC EXAMPLE MAN)
    set (VAR "INSTALL_${P}_DIR")
    set (${VAR} "${${VAR}}/@PROJECT_NAME_INFIX@")
  endforeach ()
endif ()


## @}
# end of Doxygen group
