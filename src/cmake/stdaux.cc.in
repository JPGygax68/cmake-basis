/*!
 * \file  stdaux.cc
 * \brief Implementation of standard auxiliary functions.
 *
 * \note The file stdaux.cc is automatically generated by BASIS from the
 *       file stdaux.cc.in which is part of BASIS.
 *
 * Copyright (c) 2011 University of Pennsylvania. All rights reserved.
 * See COPYING file or https://www.rad.upenn.edu/sbia/software/license.html.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 */


#include <sbia/basis/path.h>

#include "config.h"
#include "stdaux.h"


using namespace std;


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_BEGIN


// ===========================================================================
// executable information
// ===========================================================================

// ***************************************************************************
void PrintDefaultVersion ()
{
    cout << GetExecutableName () << "(" << cProjectName << ") version " << cVersion << endl;
    cout << "Copyright (c) 2011 University of Pennsylvania. All rights reserved." << endl;
    cout << "See COPYING file or https://www.rad.upenn.edu/sbia/software/license.html." << endl;
}

// ***************************************************************************
void PrintDefaultContact ()
{
    cout << "Contact:" << endl;
    cout << "  SBIA Group <sbia-software at uphs.upenn.edu>" << endl;
}

// ===========================================================================
// installation directories
// ===========================================================================

// ***************************************************************************
bool ExecutingInBuildTree ()
{
    // get directory of executable if not specified
    execDir = GetExecutableDirectory ();
    // make path relative to top directory of build tree
    string relPath = ToRelativePath (cBuildRoot, execDir);
    // return whether executable directory is inside the build tree or not
    return !(relPath == "" || relPath == "." ||
            (relPath.substr (0, 2) == ".." && (relPath.size () == 2 || relPath [2] == '/')));
}

// ***************************************************************************
string GetInstallationPrefix ()
{
#ifdef LIBEXEC
    return JoinPaths (GetExecutableDirectory (), cLibexecPrefix);
#else
    return JoinPaths (GetExecutableDirectory (), cRuntimePrefix);
#endif
}

// ***************************************************************************
string GetRuntimeDirectory ()
{
    if (ExecutingInBuildTree ()) {
        return cRuntimeBuildPath;
    } else {
        return JoinPaths (GetInstallationPrefix (), cRuntimePath);
    }
}

// ***************************************************************************
string GetLibexecDirectory ()
{
    if (ExecutingInBuildTree ()) {
        return cLibexecBuildPath;
    } else {
        return JoinPaths (GetInstallationPrefix (), cLibexecPath);
    }
}

// ***************************************************************************
string GetLibraryDirectory ()
{
    if (ExecutingInBuildTree ()) {
        return cLibraryBuildPath;
    } else {
        return JoinPaths (GetInstallationPrefix (), cLibraryPath);
    }
}

// ***************************************************************************
string GetDataDirectory ()
{
    if (ExecutingInBuildTree ()) {
        return cDataBuildPath;
    } else {
        return JoinPaths (GetInstallationPrefix (), cDataPath);
    }
}

// ===========================================================================
// information about executable targets
// ===========================================================================

// ---------------------------------------------------------------------------
// construction / destruction
// ---------------------------------------------------------------------------

// ***************************************************************************
ExecutableTargetInfo
::ExecutableTargetInfo ()
{
    // the following code is automatically generated by the BASIS CMake
    // function basis_configure_ExecutableTargetInfo()
@EXECUTABLE_TARGET_INFO_CONFIG@
}

// ***************************************************************************
ExecutableTargetInfo
::~ExecutableTargetInfo ()
{
}

// ---------------------------------------------------------------------------
// public interface
// ---------------------------------------------------------------------------

// ***************************************************************************
string
ExecutableTargetInfo
::GetTargetUID (const string &targetName) const
{
    string uid;
    const bool isSubproject = @IS_SUBPROJECT_CONFIG@;
    if (!isSubproject && targetName.find ("@BASIS_NAMESPACE_SEPARATOR@") == string::npos) {
        uid = cProjectName + "@BASIS_NAMESPACE_SEPARATOR@" + targetName;
    } else {
        uid = targetName;
    }
    return uid;
}

// ***************************************************************************
bool
ExecutableTargetInfo
::IsKnownTarget (const string &targetName) const
{
    return _execNames.find (GetTargetUID (targetName)) != _execNames.end ();
}

// ***************************************************************************
string
ExecutableTargetInfo
::GetExecutableName (const string &targetName) const
{
    string uid = GetTargetUID (targetName);
    MapIterator it = _execNames.find (uid);
    if (it == _execNames.end ()) return "";
    return it->second;
}

// ***************************************************************************
string
ExecutableTargetInfo
::GetBuildDirectory (const string &targetName) const
{
    string uid = GetTargetUID (targetName);
    MapIterator it = _buildDirs.find (uid);
    if (it == _buildDirs.end ()) return "";
    return it->second;
}

// ***************************************************************************
string
ExecutableTargetInfo
::GetInstallationDirectory (const string &targetName) const
{
    string uid = GetTargetUID (targetName);
    MapIterator it = _installDirs.find (uid);
    if (it == _installDirs.end ()) return "";
    return JoinPaths (GetInstallationPrefix (), it->second);
}

// ===========================================================================
// mapping of build target name to executable file path
// ===========================================================================

// ***************************************************************************
string GetExecutableFile (const string &targetName)
{
    // get executable target information instance
    info = ExecutableTargetInfo::GetInstance ();
    // get name of executable and check if target name is known
    string execName = info.GetExecutableName (targetName);
    // is this target known?
    if (execName.empty ()) return "";
    // prepend either build tree directory or installation directory
    if (ExecutingInBuildTree ()) {
        return JoinPaths (info.GetBuildDirectory (targetName), execName);
    } else {
        return JoinPaths (info.GetInstallationDirectory (targetName), execName);
    }
}


SBIA_@PROJECT_NAME_UPPER@_NAMESPACE_END

