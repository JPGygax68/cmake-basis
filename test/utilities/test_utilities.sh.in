#! /usr/bin/env bash

##############################################################################
# @file  test_utilities.sh
# @brief Test BASIS utilities.
#
# This test first builds the test project which is based on BASIS and then
# triggers the execution of the separate test cases which are built as part
# of this test project.
#
# Copyright (c) 2011 University of Pennsylvania. All rights reserved.
# See https://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
#
# Contact: SBIA Group <sbia-software at uphs.upenn.edu>
##############################################################################

@BASIS_BASH_UTILITIES@

# ============================================================================
# constants
# ============================================================================

readonly BASIS_DIR='@TESTING_BASIS_DIR@'
readonly RESSOURCES_DIR='@TESTING_DIR@/ressources/test_utilities'
readonly SOURCE_DIR='@TESTING_OUTPUT_DIR@/test_utilities-source'
readonly BUILD_DIR='@TESTING_OUTPUT_DIR@/test_utilities-build'

get_executable_path BASISPROJECT 'basis::basisproject.sh'
[ -z "${BASISPROJECT}" ] && { echo "FAILED to get path of basisproject command!"; exit 1; }
readonly BASISPROJECT

readonly cwd="$(pwd)"

# ============================================================================
# options
# ============================================================================

FLAGS "$@" || exit $?
eval set -- "${FLAGS_ARGV}"

# ============================================================================
# helpers
# ============================================================================

##############################################################################
# @brief Run command with arguments and exit on failure.
function run
{
    if [ ${FLAGS_verbose} -gt 0 ]; then
        echo "\$> $@"
    fi
    "$@"
    local errcode=$?
    if [ ${errcode} -ne 0 ] ; then
        echo
        echo "Failed to run command $@" 1>&2
        echo
        echo "FAILED"
        exit ${errcode}
    fi
    return 0
}

##############################################################################
# @brief Run command with arguments where error is expected.
function runerr
{
    if [ ${FLAGS_verbose} -gt 0 ]; then
        echo "\$> $@"
    fi
    "$@"
    local errcode=$?
    if [ ${errcode} -eq 0 ] ; then
        echo
        echo "Command $@ was unexpectedly successful" 1>&2
        echo
        echo "FAILED"
        exit 1
    fi
    return 0
}

##############################################################################
# @brief Creates a project using the basisproject command-line tool.
function create
{
    echo "Creating test project..."
    [ -d "${SOURCE_DIR}" ] && run rm -rf "${SOURCE_DIR}"
    # attention: changing the project name will affect the tests!
    run "${BASISPROJECT}" \
        --name 'UtilitiesTest' \
        --description "A project used to test the BASIS utilities." \
        --root "${SOURCE_DIR}" \
        --language CXX \
        --language Java \
        --language Python \
        --language Perl \
        --language BASH \
        --language MATLAB
    echo "Creating test project... - done"
}

##############################################################################
# @brief Tries to build a project created by basisproject.
function build
{
    echo "Configuring test project..."
    [ -d "${BUILD_DIR}" ] && run rm -rf "${BUILD_DIR}"
    run mkdir -p "${BUILD_DIR}"
    run cd "${BUILD_DIR}"
    run cmake "-DCMAKE_BUILD_TYPE=@TESTING_BUILD_TYPE@" "-DBASIS_DIR=${BASIS_DIR}" "${SOURCE_DIR}"
    echo "Configuring test project... - done"
    echo "Building test project..."
    if [ ${FLAGS_verbose} -gt 0 ]; then
        run make 'VERBOSE=1'
    else
        run make
    fi
    echo "Building test project... - done"

    run cd "${cwd}"
}

##############################################################################
# @brief Copy file from ressources directory to project source tree.
#
# @param [in] file   File path relative to top directory of ressources tree.
# @param [in] prefix Path prefix relative to project source tree. Defaults
#                    to the root of the project source tree itself.
# @param [in] name   Name of file in project source tree. Defaults to the
#                    name of the file given by @p file.
#
# @returns Nothing.
function copy
{
    local file=$1
    local prefix=${2:-'.'}
    local name=${3:-"$(basename "$file")"}
    run cp "${RESSOURCES_DIR}/${file}" "${SOURCE_DIR}/${prefix}/$(dirname "$file")/${name}"
}

##############################################################################
# @brief Add test to test project.
function add_test
{
    local impl=$1
    local target=${1%\.*}
    copy ${impl} 'test'
    echo "basis_add_test (\"${target}\" SOURCES \"${impl}\" $2)" >> "${SOURCE_DIR}/test/CMakeLists.txt"
}

##############################################################################
# @brief Add executable to test project.
function add_executable
{
    local impl=$1
    local target=${1%\.*}
    copy ${impl} 'src'
    echo "basis_add_executable (\"${target}\" \"${impl}\" $2)" >> "${SOURCE_DIR}/src/CMakeLists.txt"
}

##############################################################################
# @brief Cleanup source and binary tree.
function cleanup
{
    [ -d "${SOURCE_DIR}" ] && run rm -rf "${SOURCE_DIR}"
    [ -d "${BUILD_DIR}"  ] && run rm -rf "${BUILD_DIR}"
}

# ============================================================================
# main
# ============================================================================

create
add_executable 'helloworld.cxx'
add_test 'test_ExecutableTargetInfo.cxx' UNITTEST
add_test 'test_executabletargetinfo.py.in' WITH_EXT
add_test 'test_ExecutableTargetInfo.pl.in' WITH_EXT
add_test 'test_executabletargetinfo.sh.in' WITH_EXT
add_test 'test_stdaux.cxx' UNITTEST
add_test 'test_stdaux.py.in' WITH_EXT
add_test 'test_stdaux.pl.in' WITH_EXT
add_test 'test_stdaux.sh.in' WITH_EXT
build
run cd "${BUILD_DIR}"
if [ ${FLAGS_verbose} -gt 0 ]; then
    run ctest -V -V "$@"
else
    run ctest -V "$@"
fi
cd "${cwd}"
#cleanup
exit 0
